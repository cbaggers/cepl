<!DOCTYPE html> <html xmlns="http://www.w3.org/1999/xhtml"> <head> <meta charset="utf-8"/> <title>CEPL</title> <link href="cepl-styles.css" rel="stylesheet" type="text/css"/> </head> <body> <header> <h1>cepl</h1> <span class="version"/> <p class="description">Fast lispy way to work with OpenGL</p> </header> <div id="content">  <article><h2>CEPL (Code Evaluate Play Loop) - [Beta]</h2> <p>CEPL is a lispy and REPL-friendly Common Lisp library for working with OpenGL.</p> <p>Its definition of success is making the user feel that GPU programming has always been part of the languages standard.</p> <p>The usual approach to using CEPL is to start it at the beginning of your Lisp session and leave it open for the duration of your work. You can then treat the window it creates as just another output for your graphics, analogous to how <code><a href="http://l1sp.org/cl/*standard-output*">*standard-output*</a></code> is treated for text.</p> <p>CEPL is in beta. The API is close to what it needs to be but there are still many bugs to fix, features to add, and experiences to smooth out.</p> <p>See the <a href="https://github.com/cbaggers/cepl.examples">cepl.examples repository</a> for some examples of how CEPL can be used</p> <p>Videos: http://www.youtube.com/playlist?list=PL2VAYZE_4wRKKr5pJzfYD1w4tKCXARs5y</p> <h3>Installing</h3> <p>Run <code>(ql:quickload :cepl)</code> at your REPL.</p> <h3>Cloning</h3> <p>Whist it is recommended to get CEPL from quicklisp, if you clone please note that <code>master</code> is not the stable branch. Please use <code>release-quicklisp</code> for the stable code that will be in the next CEPL release.</p> <h3>Documentation</h3> <p>Currently we have full documentation of every exported symbol in the CEPL package. You can find this <a href="http://techsnuffle.com/cepl/api.html">here: CEPL API Docs</a></p> <p>Guides will be provided in future, however these take much longer to write.</p> <p>I can also be reached by my email (techsnuffle [at] gmail · com) and sometimes on #lispgames IRC. Come to #lispgames anyway though, there are some lovely folks, all lispy dialects welcome!</p> <h3>Requirements</h3> <p>All of the following will be downloaded automatically by quicklisp</p> <ul> <li>cffi</li> <li>cl-autowrap</li> <li>cl-fad</li> <li>cl-opengl</li> <li>cl-plus-c</li> <li>cl-ppcre</li> <li>documentation-utils</li> <li>fn</li> <li>ieee-floats</li> <li>named-readtables</li> <li>varjo</li> <li>rtg-math</li> <li>rtg-math.vari</li> <li>closer-mop</li> <li>bordeaux-threads</li> </ul> <h4>C Library dependency</h4> <p>CEPL uses OpenGL ( version &gt;= 3.1 ) so you need to make sure it is available on your machine. Installing your GPU drivers will usually handle this.</p> <h4>CEPL's Host</h4> <p>CEPL abstracts working with OpenGL but is not responsible for creating a window or GL context; this is handled by a <code>Host</code>. Right now the only supported host is <code>SDL2</code>; the system to load is called <code>cepl.sdl2</code>, you can find it here: <a href="https://github.com/cbaggers/cepl.sdl2">cepl.sdl2</a></p> <h3>Getting Started</h3> <p><em>Note:</em> On <code>OSX</code>, <code>slime</code> users may want to add the code specifed in <code>docs/single-thread-swank.md</code> to their Emacs config file, and use the command <code>slime-style</code> which will start <code>slime</code> in a more OpenGL friendly mode. Then follow the rest of this as usual.</p> <p>To load CEPL and the default host (<code>sdl2</code>) do the following:</p> <ul> <li><code>(ql:quickload :cepl.sdl2)</code></li> <li><code>(cepl:repl)</code></li> </ul> <p>You should see an empty window appear, OpenGL is now initialized, and you can use CEPL as you like.</p> <h3>Making a CEPL Project</h3> <p>The best way to get started is to make a new project that uses CEPL. Do the following in your REPL to get set up:</p> <ul> <li>First, run <code>(ql:quickload :cepl)</code></li> <li>Then run <code>(ql:quickload :quickproject)</code>. CEPL uses this to create a lisp project using its own templates</li> <li>Then run <code>(cepl:make-project &quot;my-proj&quot;)</code>. This will use quickproject to make a new project with all the correct dependencies. Remember that cepl does not handle window managers or input so by default your new project will use the following</li> <li>cepl for the graphics</li> <li><a href="https://github.com/cbaggers/cepl.sdl2">cepl.sdl2</a> for the host</li> <li><a href="https://github.com/cbaggers/skitter">skitter</a> for handling input and events</li> <li><a href="https://github.com/cbaggers/dirt">dirt</a> for loading images</li> </ul> <p>You are now ready to get started. Simply run:
- <code>(ql:quickload &quot;my-proj&quot;)</code> - <code>(<a href="http://l1sp.org/cl/in-package">in-package</a> :my-proj)</code> - and finally (if you havent already) <code>(cepl:repl)</code></p> <h4>Windows C Library Hack</h4> <p>If you are having issues getting the C libraries to load and just need to rule out whether Lisp can find them, try putting them in the same folder as the lisp exe. For example <code>C:\Program Files\sbcl\</code>.</p> <h2>CHANGELOG</h2> <h3>2017-06-04</h3> <ul> <li><p>pipelines can take <code>:dynamic</code> as their draw mode. This means they will take the draw-mode from the <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> they are mapped over. This only works for pipelines with <code>vertex</code> &amp; <code>fragment</code> stages.</p></li> <li><p><code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code>s now hold the primitive type of their data. Defaults to <code>:triangles</code></p></li> <li><p>Fix bug that was stopping g-structs contain matrices</p></li> <li><p>Cache more values in <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> to save time during rendering</p></li> <li><p>Add <code>surface-dimensions</code>, <code>surface-resolution</code>, <code>surface-title</code> &amp; <code>surface-fullscreen-p</code></p></li> <li><p>add <code>adjust-gpu-array</code> (pretty basic right now)</p></li> <li><p>Remove <code>cepl.spaces</code>, It is now a seperate project (and will be in quicklisp in the next cycle)</p></li> <li><p>Remove <code>cepl.misc</code>. If you were using the <code>draw-texture</code> function then please consider <code>Nineveh</code> (which will be in quicklisp in the next cycle)</p></li> <li><p><code>make-project</code> now uses <code>dirt</code> instead of <code>devil</code>. <code>dirt</code> uses <code>cl-soil</code> which ships with binaries for multiple paltforms so has a better 'out of the box' experience (plus also supports more formats)</p></li> </ul> <h3>2017-05-16</h3> <p><em>I missed some logs here so this is a recap of everything since 2017-02-19</em></p> <ul> <li><p>Geometry &amp; Tessellation fully supported (including for inline glsl stages)</p></li> <li><p>Draw mode can now be specified for pipelines</p></li> <li><p>fixes for pull-g with gpu-functions &amp; pipelines</p></li> <li><p>add <code><a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-POINTER">with-gpu-array-range-as-pointer</a></code> &amp; <code><a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-C-ARRAY">with-gpu-array-range-as-c-array</a></code>. These still feel experimental to me.</p></li> <li><p>add <code><a href="#CEPL.GPU-ARRAYS:REALLOCATE-GPU-ARRAY">reallocate-gpu-array</a></code> &amp; <code><a href="#CEPL.GPU-BUFFERS:REALLOCATE-BUFFER">reallocate-buffer</a></code></p></li> <li><p>buffer-streams always hold on to their gpu-arrays by default</p></li> <li><p>Refactoring based on changes in Varjo</p></li> <li><p>Added bordeux-threads as a dependency. Will be needed for some context related things</p></li> <li><p>Very basic support for multiple surfaces (windows)</p></li> <li><p>New 'host' api. Is versioned so old hosts are still supported</p></li> <li><p>remove <code>run-session</code>. All of these attempts at thread hackery felt bad. I'm sticking with <code>slime-style</code> until we have a better fix</p></li> </ul> <h3>2017-02-19</h3> <ul> <li>Removed the <code>continuable</code> macro. The macro can be found in the <code>livesupport</code> project. Simply <code>(ql:quickload :livesupport)</code></li> </ul> </article>  <article>  <h2>Copyright</h2> <span>cepl</span> is licensed under the <span><a href="https://tldrlegal.com/search?q=BSD 2 Clause">BSD 2 Clause</a></span> license.  © <span>Chris Bagley (Baggers) &lt;techsnuffle@gmail.com&gt;</span> .    </article>  <article id="symbol-index"> <h2>Package Index</h2> <ul><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.C-ARRAYS" href="#CEPL.C-ARRAYS">CEPL.C-ARRAYS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:C-ARRAY"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.C-ARRAYS:C-ARRAY">C-ARRAY</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.C-ARRAYS:C-ARRAY">C-ARRAY</a></code> is a structure that represents an array in foreign memory.</p> <p>CEPL keeps not only the pointer to the foreign data in this structure
but also metadata that makes moving this data to (and from) the gpu or
lisp much easier.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:AREF-C"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:AREF-C">AREF-C</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY &amp;REST SUBSCRIPTS</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Accesses the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> element specified by the subscripts</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:AREF-C*"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:AREF-C*">AREF-C*</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY SUBSCRIPTS</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Accesses the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> element specified by the subscripts.</p> <p>The difference between this and <code><a href="#CEPL.C-ARRAYS:AREF-C">aref-c</a></code> is that this this function takes the
subscripts as a list.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:C-ARRAY-DIMENSIONS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:C-ARRAY-DIMENSIONS">C-ARRAY-DIMENSIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p><code><a href="#CEPL.C-ARRAYS:C-ARRAY-DIMENSIONS">C-ARRAY-DIMENSIONS</a></code> takes a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> as an argument and returns the
dimensions of the c-array</p> <p>You can also use the generic function <code><a href="#CEPL.MEASUREMENTS:DIMENSIONS">DIMENSIONS</a></code> to get the same
result.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:C-ARRAY-ELEMENT-TYPE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:C-ARRAY-ELEMENT-TYPE">C-ARRAY-ELEMENT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p><code><a href="#CEPL.C-ARRAYS:C-ARRAY-POINTER">C-ARRAY-POINTER</a></code> takes a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> as an argument and returns the
type of the elements of the array.</p> <p>You can also use the generic function <code><a href="#CEPL.C-ARRAYS:ELEMENT-TYPE">ELEMENT-TYPE</a></code> to get the same
result.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:C-ARRAY-POINTER"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:C-ARRAY-POINTER">C-ARRAY-POINTER</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p><code><a href="#CEPL.C-ARRAYS:C-ARRAY-POINTER">C-ARRAY-POINTER</a></code> takes a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> as an argument and returns the
pointer to the foreign data.</p> <p>You can also use the generic function <code><a href="#CEPL.C-ARRAYS:POINTER">POINTER</a></code> to get the same result.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:ACROSS-C-PTR"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:ACROSS-C-PTR">ACROSS-C-PTR</a> </code> <code class="qualifiers"></code> <code class="arguments">FUNCTION C-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes two arguments:</p> <ul> <li>A function that takes a pointer and a fixnum</li> <li>A <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code></li> </ul> <p><code><a href="#CEPL.C-ARRAYS:ACROSS-C-PTR">across-c-ptr</a></code> will then call the given function once for every element in the
c-array passing in the pointer to an element of the array and the index to that
element.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:C-ARRAY-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:C-ARRAY-P">C-ARRAY-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Return t if the argument is a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>. Returns nil otherwise.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:CLONE-C-ARRAY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:CLONE-C-ARRAY">CLONE-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Takes a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> and makes a new c-array with the same contents as the the
original. The contents in foreign memory are copied.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:FREE-C-ARRAY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:FREE-C-ARRAY">FREE-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Frees the foreign memory allocated with the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> and 'blanks' the c-array.</p> <p>Blanking the c-array means its fields will be set to default values,
for example dimensions will be 0, the pointer will be null etc.</p> <p>The generic function <code><a href="#CEPL.MEMORY:FREE">free</a></code> will call <code><a href="#CEPL.C-ARRAYS:FREE-C-ARRAY">free-c-array</a></code> when passed a c-array.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:MAKE-C-ARRAY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:MAKE-C-ARRAY">MAKE-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">INITIAL-CONTENTS &amp;KEY DIMENSIONS ELEMENT-TYPE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will make and return a new <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> <p>It can be used in a few different ways:</p> <ul> <li><p>with :initial-contents to nil:
  In this case you need to provide dimensions and an element-type.</p></li> <li><p>with :initial-contents populated.
  The initial-contents can be a (potentially nested) list or array.</p></li> </ul> <p>When :initial-contents is an array then the dimension of the c-array
will be the same as the array passed in. CEPL currently only supports up
to 4D c-arrays.</p> <p>When the :initial-contents is a flat list then each element is used as one
element in the c-array.
If the :initial-contents is a nested list then you must either:</p> <ul> <li>specify multiple dimensions and an element-type</li> <li>specify an element-type to be some struct type, then nested lists are then
  used to populate the fields of the foreign structs. For an example of this
  please see <a href="https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30">this example</a>.</li> </ul> <p>If the :element-type is not provided then CEPL will look at every element in
the initial-contents and try and find the smallest (in bytes) foreign type
which works for every element. This mean if the array is full of single-floats
then CEPL will choose :float, not :double.
Naturally this behaviour is too slow for use in performance critical
applications however it is nice for experimentation and working from the repl.</p> <p>If you need what would be called a displaced array in lisp then please see the <code><a href="#CEPL.C-ARRAYS:SUBSEQ-C">subseq-c</a></code> function.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:MAKE-C-ARRAY-FROM-POINTER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:MAKE-C-ARRAY-FROM-POINTER">MAKE-C-ARRAY-FROM-POINTER</a> </code> <code class="qualifiers"></code> <code class="arguments">DIMENSIONS ELEMENT-TYPE POINTER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Will create a CEPL <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> with the element-type and dimensions specified,
and will store the pointer as where the data is expected to be.</p> <p>This function does allocate the memory or validate the type or dimensions so be
very careful when using this function.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:MAP-C"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:MAP-C">MAP-C</a> </code> <code class="qualifiers"></code> <code class="arguments">FUNCTION C-ARRAY &amp;OPTIONAL DESTINATION-ELEMENT-TYPE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When given a function and a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> this function will map the function across
every element of the c-array and write the results of the function into a new
c-array with the same element-type and dimensions as the original c-array.</p> <p>You may also pass in an optional foreign type that will be used as the element
type of the new array.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:MAP-C-INTO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:MAP-C-INTO">MAP-C-INTO</a> </code> <code class="qualifiers"></code> <code class="arguments">DESTINATION-C-ARRAY FUNCTION SOURCE-C-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When given a destination <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>, a function and a source c-array this function
will map the function across every element of the source c-array and write the
results of the function destrucively into the destination c-array.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:PTR-INDEX"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:PTR-INDEX">PTR-INDEX</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY &amp;OPTIONAL (X 0) (Y 0 Y-SET) (Z 0 Z-SET) (W 0 W-SET)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> and some subscripts and will return the ptr to the
specified element of the c-array</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:SUBSEQ-C"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:SUBSEQ-C">SUBSEQ-C</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY START &amp;OPTIONAL END</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> which contains a subset of the array passed into
this function.</p> <p>It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.</p> <p>Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.</p> <p>If you want a copy of a subseq of a c-array then use something like:</p> <pre><code>(<a href="#CEPL.C-ARRAYS:CLONE-C-ARRAY">clone-c-array</a> (<a href="#CEPL.C-ARRAYS:SUBSEQ-C">subseq-c</a> arr 3 10))
</code></pre> <p>The reason that this arguably more dangerous behaviour is default is efficiency.
CEPL tries not to allocate new memory when the function is not explicitly about
that.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:ELEMENT-BYTE-SIZE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:ELEMENT-BYTE-SIZE">ELEMENT-BYTE-SIZE</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>Returns the size in bytes taken up by a single element of the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:ELEMENT-TYPE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:ELEMENT-TYPE">ELEMENT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>Returns the type of the elements in the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:POINTER"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:POINTER">POINTER</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>Returns the pointer to the start of the foreign data that makes up the array</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:WITH-C-ARRAY"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:WITH-C-ARRAY">WITH-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">(VAR-NAME C-ARRAY) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>Binds the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> to the variable named by the var-name argument.
Frees the c-array at the end of the scope.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.C-ARRAYS:WITH-C-ARRAYS"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.C-ARRAYS:WITH-C-ARRAYS">WITH-C-ARRAYS</a> </code> <code class="qualifiers"></code> <code class="arguments">(VAR-NAME C-ARRAYS) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>Binds a list of <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>s to the variable named by the var-name argument.
Frees all of the c-arrays at the end of the scope.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.GPU-ARRAYS" href="#CEPL.GPU-ARRAYS">CEPL.GPU-ARRAYS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">GPU-ARRAY</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">GPU-ARRAY</a></code> is a structure that represents an array in gpu-memory.</p> <p>Depending on how the array was created it is said that the gpu-array is either
'buffer-backed' or 'texture-backed'.</p> <ul> <li>buffer-backed: Means it was created with <code><a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY">make-gpu-array</a></code> or <code><a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAYS">make-gpu-arrays</a></code> The data is stored in a gpu-buffer.</li> <li>texture-backed: Means it was created along with a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>. <code><a href="#CEPL.TEXTURES:TEXTURE">Texture</a></code>s are
              structures that contain some number of gpu-arrays.
              The data is stored in <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> memory.
              See <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> for more details.</li> </ul> <p>Both have different use cases and allow different element types, however they
are both an ordered block of typed data. They can have multiple dimensions and
you can <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> and <code><a href="#CEPL.MEMORY:PULL-G">pull-g</a></code> data to and from them.</p> <p>Note for folks who are used to OpenGL:
texture-backed gpu-arrays are what opengl would normally call 'images'. This is
a pretty terrible name for them as it implies they only can hold image data, or
that they are 2d only. In fact 'images' can have 1 to 3 dimensions, can have
elements that are single bytes, floats, vectors of either or a large number of
other types.
'image' belies this nature and so CEPL chooses 'array'</p> <p>This also matches how the GLWiki chooses to explain them:</p> <blockquote> <p>an image is defined as a single array of pixels of a certain
dimensionality (1D, 2D, or 3D), with a particular size, and a specific format.</p> </blockquote> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-DIMENSIONS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-DIMENSIONS">GPU-ARRAY-DIMENSIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Return a list whose elements are the dimensions of the array.</p> <p>You can also use the generic function <code><a href="#CEPL.MEASUREMENTS:DIMENSIONS">dimensions</a></code> to get this info.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:BACKED-BY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:BACKED-BY">BACKED-BY</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and returns either :texture or :buffer depending
on whether it is a texture-backed gpu-array or a buffer-backed gpu-array.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-ACCESS-STYLE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-ACCESS-STYLE">GPU-ARRAY-ACCESS-STYLE</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a buffer-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the access-style
of the underlying gpu-buffer.</p> <p>The access-style of a gpu-array (or <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>) is a hint to OpenGL on how you
intend to use the array. It is optional whether your gpu manufacturer's
implementation of GL takes any notice of this option. When they do take notice
of it, it will to optimize access to the underlying data.</p> <p>There are also no repercussions for accessing the data in a way contrary to the
declared access-style (other than potential performance costs).</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-BUFFER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-BUFFER">GPU-ARRAY-BUFFER</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a buffer-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> backing this array.</p> <p>Note that if you made the array with <code><a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAYS">make-gpu-arrays</a></code> then there will be
multiple gpu-arrays sharing this buffer, so care should be taken when modifying
or freeing data.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-ELEMENT-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-ELEMENT-TYPE">GPU-ARRAY-ELEMENT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Will return the type of the elements in the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> given.</p> <p>If this is a texture-backed gpu-array then the element-type will be the same as
the 'image-format' of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-FACE-NUM"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-FACE-NUM">GPU-ARRAY-FACE-NUM</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a texture-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the index of
the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>'s cubeface that contains this gpu-array. This only truly applies to
gpu-arrays belonging to cubemap <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>s, for all gpu-arrays this number will
always be 0.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-LAYER-NUM"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-LAYER-NUM">GPU-ARRAY-LAYER-NUM</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a texture-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the index of
the gpu-array within the array-textures. This only truly applies to gpu-arrays
 belonging to array-textures, for all gpu-arrays this number will always be 0.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-LEVEL-NUM"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-LEVEL-NUM">GPU-ARRAY-LEVEL-NUM</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a texture-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the
mipmap level the gpu-array resides on within the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>This only truly applies to gpu-arrays with mipmaps, for all gpu-arrays this
number will always be 0.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-P">GPU-ARRAY-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Will return t if the value given is a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>.</p> <p>This will return t for both texture-backed and buffer-backed gpu-arrays</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:GPU-ARRAY-TEXTURE-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:GPU-ARRAY-TEXTURE-TYPE">GPU-ARRAY-TEXTURE-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>When passed a texture-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this function will return the
type of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> containing this gpu-array.</p> <p>The result will be one of the following:</p> <pre><code>:texture-1d
:texture-2d
:texture-3d
:texture-1d-array
:texture-2d-array
:texture-cube-map
:texture-cube-map-array
:texture-rectangle
:texture-buffer
:texture-buffer
:texture-buffer
:texture-2d-multisample
:texture-2d-multisample-array
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:MAKE-GPU-ARRAYS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAYS">MAKE-GPU-ARRAYS</a> </code> <code class="qualifiers"></code> <code class="arguments">C-ARRAYS &amp;KEY (ACCESS-STYLE :STATIC-DRAW)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a list of x <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>s and returns a list of x buffer-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s.</p> <p>The reason to use this rather than:</p> <pre><code>(<a href="http://l1sp.org/cl/mapcar">mapcar</a> `make-gpu-array` c-arrays-list)
</code></pre> <p>is that all of the gpu-arrays created will share the same <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> <p>Usually you will know if you need this instead of <code><a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY">make-gpu-array</a></code> as you will
have some behaviour or performance characteristic in mind.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:REALLOCATE-GPU-ARRAY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:REALLOCATE-GPU-ARRAY">REALLOCATE-GPU-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and reallocates the buffer that is backing it.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:SUBSEQ-G"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:SUBSEQ-G">SUBSEQ-G</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY START &amp;OPTIONAL END</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> which contains a subset of the gpu-array
passed into this function.</p> <p>It does not copy the foreign data, instead this array points to within the data
of the original array. This means these arrays now share data (like a displaced
array in standard CL.</p> <p>Due to this you have to be very careful when freeing the underlying array as
this will affect any other array sharing that data.</p> <p>The reason that this arguably more dangerous behaviour is default is efficiency.
Mofidying gpu memory in performance critical applications should be done at
specific times so as not to get blocked by rendering commands. As such CEPL
tries not to allocate new memory when the function is not explicitly about that.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:FREE-GPU-ARRAY"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:FREE-GPU-ARRAY">FREE-GPU-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>When given a buffer-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> this will do one of three things:</p> <p>If the gpu-array is the only gpu-array in the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> then the gpu-buffer is
freed and the gpu-array is blanked.</p> <p>If the gpu-array shares a gpu-buffer with other gpu-arrays and they are still
live then blank this gpu-array.</p> <p>If the gpu-array shared a gpu-buffer with other gpu-buffer but they have all
been freed then free the gpu-buffer and blank the gpu-array.</p> <p>Blanking the gpu-array means its fields will be set to default values,
for example dimensions will be nil, the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> will be null etc.</p> <p>The generic function <code><a href="#CEPL.MEMORY:FREE">free</a></code> will call #'free-gpu-array when passed a gpu-array.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY">MAKE-GPU-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">INITIAL-CONTENTS &amp;KEY DIMENSIONS ELEMENT-TYPE ACCESS-STYLE</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function creates a buffer-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>.
Texture-backed gpu-array can only be created via #'make-texture</p> <p><code><a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY">make-gpu-array</a></code> is very similar to <code><a href="#CEPL.C-ARRAYS:MAKE-C-ARRAY">make-c-array</a></code>.</p> <p>It can be used in a few different ways:</p> <ul> <li><p>with :initial-contents to nil:
  In this case you need to provide dimensions and an element-type.</p></li> <li><p>with :initial-contents populated.
  The initial-contents can be a (potentially nested) list, array or <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p></li> </ul> <p>When the :initial-contents are a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> then the dimensions and element-type
are taken from the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>. As the data is already in foreign memory the
upload will be notable faster that from lisp-data-&gt;gpu as no type conversions
are needed</p> <p>When the :initial-contents are an array then the dimension of the gpu-array
will be the same as the array passed in. CEPL currently only supports up
to 4D gpu-arrays.</p> <p>When the :initial-contents is a flat list then each element is used as one
element in the gpu-array.</p> <p>If the :initial-contents is a nested list then you must either:</p> <ul> <li>specify multiple dimensions and an element-type</li> <li>specify an element-type to be some struct type, then nested lists are then
  used to populate the fields of the foreign structs. For an example of this
  please see <a href="https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30">this example</a>.</li> </ul> <p>If the :element-type is not provided then CEPL will look at every element in
the initial-contents and try and find the smallest (in bytes) foreign type
which works for every element. This mean if the array is full of single-floats
then CEPL will choose :float, not :double.
Naturally this behaviour is too slow for use in performance critical
applications however it is nice for experimentation and working from the repl.</p> <p>If you need what would be called a displaced array in lisp then please see the <code><a href="#CEPL.GPU-ARRAYS:SUBSEQ-G">subseq-g</a></code> function.</p> <p>Access style is optional but if you are comfortable with
opengl, and know what type of usage pattern this array will
have, you can set this to any of the following:</p> <p>The access-style argument is a hint to OpenGL on how you intend to use
the array. It is optional whether your gpu manufacturer's implementation of GL
takes any notice of this option. When they do take notice of it, it will to
optimize access to the underlying data.</p> <p>There are also no repercussions for accessing the data in a way contrary to the
declared access-style (other than potential performance costs).</p> <pre><code>:stream-draw  :static-draw  :dynamic-draw
:stream-read  :static-read  :dynamic-read
:stream-copy  :static-copy  :dynamic-copy
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-AS-C-ARRAY"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-AS-C-ARRAY">WITH-GPU-ARRAY-AS-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">(TEMP-NAME GPU-ARRAY &amp;KEY (ACCESS-TYPE :READ-WRITE)) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and asks OpenGL to temporarily 'map' it to
a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>. Within the scope of the body you can run any of the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> commands
on it.</p> <p>This macro is really helpful if you need to have random access to the data in
the gpu-array.</p> <p>A simple example would be if we wanted to set the 3rd element in a gpu array to
5.0 we could do the following:</p> <pre><code>(<a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-AS-C-ARRAY">with-gpu-array-as-c-array</a> (tmp-c-arr my-gpu-array)
  (<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.C-ARRAYS:AREF-C">aref-c</a> tmp-c-arr 2) 5.0))
</code></pre> <p>The reason we provide this and not a function like <code><a href="#CEPL.C-ARRAYS:AREF-C">aref-c</a></code> for gpu-arrays is
that it would give the impression that this kind of operation is cheap, which it
is not. There are cases where using with-gpu-array-as-c-array will perform
better than <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> and there cases where the opposite is true.</p> <p>Generally this will be to do with how much of the block of memory is being
updated, but it is best to consult current graphics programming texts to find
out the details.</p> <p>The valid values for the :access argument are :read-only :write-only or
:read-write.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-AS-POINTER"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-AS-POINTER">WITH-GPU-ARRAY-AS-POINTER</a> </code> <code class="qualifiers"></code> <code class="arguments">(TEMP-NAME GPU-ARRAY &amp;KEY (ACCESS-TYPE :READ-WRITE) (TARGET :ARRAY-BUFFER))
 &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and asks OpenGL to temporarily 'map' it to
a pointer. Within the scope of the body you can run any cffi command on it.</p> <p>This macro is really helpful if you need to have random access to the data in
the gpu-array.</p> <p>The valid values for the :access argument are :read-only :write-only or
:read-write.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-C-ARRAY"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-C-ARRAY">WITH-GPU-ARRAY-RANGE-AS-C-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">(TEMP-NAME GPU-ARRAY START-INDEX LENGTH &amp;KEY (ACCESS-SET :MAP-READ)) &amp;BODY
 BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and asks OpenGL to temporarily 'map' it a portion
of it  to a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>. Within the scope of the body you can run any of the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> commands on it.</p> <p>This macro is really helpful if you need to have random access to the data in
the gpu-array.</p> <p>A simple example would be if we wanted to set the 3rd element in a gpu array to
5.0 we could do the following:</p> <pre><code>(<a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-C-ARRAY">with-gpu-array-range-as-c-array</a> (tmp-c-arr my-gpu-array 10 20)
  (<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.C-ARRAYS:AREF-C">aref-c</a> tmp-c-arr 2) 5.0))
</code></pre> <p>The reason we provide this and not a function like <code><a href="#CEPL.C-ARRAYS:AREF-C">aref-c</a></code> for gpu-arrays is
that it would give the impression that this kind of operation is cheap, which it
is not. There are cases where using with-gpu-array-as-c-array will perform
better than <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> and there cases where the opposite is true.
Generally this will be to do with how much of the block of memory is being
updated, but it is best to consult current graphics programming texts to find
out the details.</p> <p>The valid values for the :access argument are :read-only :write-only or
:read-write.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-POINTER"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-ARRAYS:WITH-GPU-ARRAY-RANGE-AS-POINTER">WITH-GPU-ARRAY-RANGE-AS-POINTER</a> </code> <code class="qualifiers"></code> <code class="arguments">(TEMP-NAME GPU-ARRAY START-INDEX LENGTH &amp;KEY (ACCESS-SET :MAP-READ)
 (TARGET :ARRAY-BUFFER))
 &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro takes a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and asks OpenGL to temporarily 'map' a portion
ofit to a pointer. Within the scope of the body you can run any cffi command
on it.</p> <p>This macro is really helpful if you need to have random access to the data in
the gpu-array.</p> <p>The valid values for the :access argument are :read-only :write-only or
:read-write.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.STREAMS" href="#CEPL.STREAMS">CEPL.STREAMS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM">BUFFER-STREAM</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>A buffer-stream is a structure that represents stream of gpu-data composed from
gpu-array and/or gpu-buffers.</p> <p>To render in CEPL we map a buffer-stream over a gpu-pipeline. The buffer-stream
contains data (usually geometry) that is passed to the vertex-shader.</p> <p>A buffer-stream composes various sources of gpu-data together. So if, for example,
the vertex shader took 3 arguments of types :vec2 :vec3 :float. Then you could
make a stream that composes 3 gpu-arrays with element-types :vec2 :vec3 :float
and map this over the pipeline.</p> <p>Naturally, as we are talking about buffer-stream, only buffer-backed gpu-arrays
can be composed with buffer-streams.</p> <p>Info for people used to OpenGL:
A buffer-stream is basically a VAO with some extra metadata such as the 'range'
of data to draw the 'style' of drawing &amp; the 'primitive' the data represents .</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM-GPU-ARRAYS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM-GPU-ARRAYS">BUFFER-STREAM-GPU-ARRAYS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>When you construct a buffer-stream it will (by default) hold onto the
gpu-arrays that were composed.</p> <p>This function when given a buffer-stream will return those stored gpu-arrays</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM-INDEX-TYPE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM-INDEX-TYPE">BUFFER-STREAM-INDEX-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">STREAM</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>When passed a buffer-stream with an index this function will return the
element-type of the index-data.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM-LENGTH"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM-LENGTH">BUFFER-STREAM-LENGTH</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the number of elements in the buffer-stream</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM-VAO"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM-VAO">BUFFER-STREAM-VAO</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the OpenGL Vertex Array Object (VAO) owned by this stream.</p> <p>Do not modify this unless you are sure what you are doing.
In most cases you do not need to interact with the VAO directly</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:BUFFER-STREAM-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:BUFFER-STREAM-P">BUFFER-STREAM-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Returns t if the value passed is a buffer-stream</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:FREE-BUFFER-STREAM"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:FREE-BUFFER-STREAM">FREE-BUFFER-STREAM</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER-STREAM</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Calling this with a buffer-stream will free the VAO owned by this buffer-stream
and blank the buffer-stream object.</p> <p>It will not free any of the gpu-data that was composed to make this stream.</p> <p>Calling the generic function <code><a href="#CEPL.MEMORY:FREE">free</a></code> with a buffer-stream will call this function</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.STREAMS:MAKE-BUFFER-STREAM"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.STREAMS:MAKE-BUFFER-STREAM">MAKE-BUFFER-STREAM</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAYS &amp;KEY INDEX-ARRAY (START 0) LENGTH (RETAIN-ARRAYS T)
 (PRIMITIVE :TRIANGLES)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function composes a number of gpu-arrays into a buffer-stream.
No data is copied, the buffer-stream simply refers to the gpu-arrays so the
gpu knows where to pull data from.</p> <p>You can optionally pass a gpu-array to act as an index into the other arrays.</p> <p>Usually when you map over a buffer-stream it will call the pipeline pulling 1
value from each of the composed gpu-arrays on each 'iteration'[0].
When you have an index then map-g will pull 1 value from index each 'iteration'
and use that to pick which value to use from the other arrays. This approach
gives bigs boosts in performance and memory usage when rendering.</p> <p>The element-type of the index-array must be of the following:
:uint8 :ushort :uint :unsigned-short :unsigned-int</p> <p>As well as an element type you also can specify the primitive-type. This says
what the gpu will draw this data as. It can be any one of:</p> <p>:points
:lines
:line-loop
:line-strip
:lines-adjacency
:line-strip-adjacency
:triangles
:triangle-fan
:triangle-strip
:triangles-adjacency
:triangle-strip-adjacency
(:patch <patch-size>)</patch-size></p> <p>By default the primtive-type is :triangles</p> <p>It is also worth noting  that you can also use gpu-sub-arrays in here if you
want to limit the data you are using, for example the following is perfectly
legal code:</p> <pre><code>(<a href="#CEPL.STREAMS:MAKE-BUFFER-STREAM">make-buffer-stream</a>
  :gpu-arrays `(,(gpu-sub-array monster-pos-data 1000 2000)
               ,(gpu-sub-array monster-col-data 1000 2000))
  :index-array monster-index-array
  :length 1000)
</code></pre> <p>[0] The use of the term 'iteration' here is quoted as the gpu is going to be
    doing this work in parallel, however it makes the explanation clearer so
    that is why it is there. If you have a clearer way of explaining the
    behaviour please file it as an issue on github.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.VIEWPORTS" href="#CEPL.VIEWPORTS">CEPL.VIEWPORTS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT">VIEWPORT</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.VIEWPORTS:VIEWPORT">Viewport</a></code> is a structure that represents a retangular region of the surface
that CEPL can draw into.</p> <p>There is always a viewport current when rendering. If one of your own is not
current then CEPL will use its default viewport, the resolution of which is the
same as that of the surface when it was created.</p> <p>The default viewport can be modified, so feel free to update the resolution if
the surface size changes.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT">VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJ</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This is a placeholder generic function for future apis.
Feel free to implement this in your own programs when yo want to get a <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> from some container</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-DIMENSIONS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-DIMENSIONS">VIEWPORT-DIMENSIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the resolution of the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> as a list of integers</p> <p>If you call the generic function <code><a href="#CEPL.MEASUREMENTS:DIMENSIONS">dimensions</a></code> with a viewport you will get
this value.</p> <p>If you need this value as a vec2 use <code><a href="#CEPL.VIEWPORTS:VIEWPORT-RESOLUTION">viewport-resolution</a></code> or just the
generic function <code><a href="#CEPL.MEASUREMENTS:RESOLUTION">resolution</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-ORIGIN"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-ORIGIN">VIEWPORT-ORIGIN</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the origin of the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code>.</p> <p>This is the top-left corner of the rectangle within the surface that OpenGL (and
thus CEPL) will draw into</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-RESOLUTION"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-RESOLUTION">VIEWPORT-RESOLUTION</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the resolution of the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> as a vec2</p> <p>If you call the generic function <code><a href="#CEPL.MEASUREMENTS:RESOLUTION">resolution</a></code> with a viewport you will get
this value.</p> <p>If you need this value as a list use <code><a href="#CEPL.VIEWPORTS:VIEWPORT-DIMENSIONS">viewport-dimensions</a></code> or just the
generic function <code><a href="#CEPL.MEASUREMENTS:DIMENSIONS">dimensions</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:COPY-VIEWPORT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:COPY-VIEWPORT">COPY-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns a new <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> with identical origin and resolution to the
viewport provided.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:CURRENT-VIEWPORT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:CURRENT-VIEWPORT">CURRENT-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments"></code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> that is current in this scope.</p> <p>If no other code in the callstack has used <code><a href="#CEPL.VIEWPORTS:WITH-VIEWPORT">with-viewport</a></code> or <code><a href="#CEPL.VIEWPORTS:WITH-FBO-VIEWPORT">with-fbo-viewport</a></code> then the result will be the default viewport.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:MAKE-VIEWPORT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:MAKE-VIEWPORT">MAKE-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;OPTIONAL (RESOLUTION '(320 240)) (ORIGIN '(0 0))</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns a new <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> with the specified resolution and
origin</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-P">VIEWPORT-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will return t if the value given is a <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code>, otherwise it will
return nil</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-PARAMS-TO-VEC4"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-PARAMS-TO-VEC4">VIEWPORT-PARAMS-TO-VEC4</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;OPTIONAL (VIEWPORT (CURRENT-VIEWPORT))</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Will return a vec4 packed with the origin and resolution. The format is as
follows:</p> <pre><code>(v! origin-x origin-y resolution-x resolution-y)
</code></pre> <p>If now viewport is provided the the <code><a href="#CEPL.VIEWPORTS:CURRENT-VIEWPORT">current-viewport</a></code> is used.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-RESOLUTION-X"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-RESOLUTION-X">VIEWPORT-RESOLUTION-X</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns the x component of the resolution of the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> as
a float.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:VIEWPORT-RESOLUTION-Y"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:VIEWPORT-RESOLUTION-Y">VIEWPORT-RESOLUTION-Y</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns the y component of the resolution of the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> as
a float.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:WITH-FBO-VIEWPORT"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:WITH-FBO-VIEWPORT">WITH-FBO-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">(FBO &amp;OPTIONAL (ATTACHMENT 0)) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro behaves similarly to with-viewport in that is sets the
current <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code>. However rather than passing in a viewport, one is
created[0] based on the dimensions of the gpu-array bound as the specified
attachment to the given fbo.</p> <p>By default color-attachment0 will be used but you can provide your own
attachment index using the :attachment argument.</p> <p>It will remain as the <code><a href="#CEPL.VIEWPORTS:CURRENT-VIEWPORT">current-viewport</a></code> until the end of the scope.</p> <p>[0] CEPL is free to reuse internal viewport objects where it makes sense instead
    of consing up a new viewport. This means that the viewport inside the scope
    may be eq to the viewport outside, but with different values in its slots
    for the duration of the body.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VIEWPORTS:WITH-VIEWPORT"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VIEWPORTS:WITH-VIEWPORT">WITH-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">VIEWPORT &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro sets the current <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> to the viewport given as the argument.
It will remain as the <code><a href="#CEPL.VIEWPORTS:CURRENT-VIEWPORT">current-viewport</a></code> until the end of the scope.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.TEXTURES" href="#CEPL.TEXTURES">CEPL.TEXTURES</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.TEXTURES:*IMMUTABLE-AVAILABLE*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.TEXTURES:*IMMUTABLE-AVAILABLE*">*IMMUTABLE-AVAILABLE*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>After CEPL has been initialized this variable will hold t if immutable <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> storage is available and nil if not.</p> <p>Immutable texture storage does not mean that the texture's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> data is
immutable. It means that the underlying format of the texture data cannot be
changed. It is rare that you would want mutable storage and when you do, it is
very hard to not create 'incomplete-textures'.
https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness</p> <p>CEPL tries to make only complete textures so this is not a concern. If you do
need this level of control, please raise a github issue as I would love to
understand your usecase.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:BUFFER-TEXTURE"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TEXTURES:BUFFER-TEXTURE">BUFFER-TEXTURE</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.TEXTURES:BUFFER-TEXTURE">Buffer-texture</a></code>s are a special kind of <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> where the data resides, not in
texture memory, but in buffer memory.</p> <p>This means that when you call texref on this texture you will recieve a
buffer-backed texture instead of the usual texture-backed ones.</p> <p>buffer-textures are created by calling <code><a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a></code> with the :buffer key
argument set to t.</p> <p>Buffer textures have limitations over regular textures:</p> <ul> <li>cannot be mipmapped</li> <li>can only only have one <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code></li> <li>that gpu-array must be one dimensional</li> <li>can only be accessed in shaders with #'texel-fetch</li> <li>can have a more limited number of valid element-types[0] to choose from
  see <em>valid-image-formats-for-buffer-backed-texture</em> for details</li> </ul> <p>[0] OpenGL calls the element-types of textures 'image-formats' or sometimes
    'internal-formats'. Even though the name implies they are only useful
    for image data we keep the name as the subject of image-formats is
    complicated enough without us adding more things to think about</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TEXTURES:TEXTURE">TEXTURE</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.TEXTURES:TEXTURE">Texture</a></code>s are structures that hold a number of <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s that all have the same
element-type.</p> <p>Textures can be used as a source of data or can be attached to an fbo, which
means you can render into them instead of to the screen[0].</p> <p>These texture-backed arrays cannot contain arbitrary data, they are specific
formats that are allowed in specific circumstances. CEPL makes working with
these as smooth as possible, but the details are confusing and the best sources
of information for the nitty-gritty are the GL-Wiki and the GL-Specification.</p> <p><strong>-- Texture Types --</strong></p> <p>The textures themselves have a number of configurations (known from here on as
'texture-types') that are allowed:</p> <pre><code>:texture-1d
Gpu-Arrays in this texture all are 1-dimensional.

:texture-2d
Gpu-Arrays in this texture all are 2-dimensional.

:texture-3d
Gpu-Arrays in this texture all are 3-dimensional.

:texture-rectangle
This texture only has one 2-dimensional gpu-array. The texture cannot have
mipmapping. Texture coordinates used for these textures are not normalized.

:texture-buffer
See the documentation for `buffer-texture` for details

:texture-cube-map
There are exactly 6 distinct sets of 2D gpu-arrays, all of the same size.
They act as 6 faces of a cube.

:texture-1d-array
Gpu-Arrays in this texture all are 1-dimensional. However, it contains
multiple sets of 1-dimensional gpu-arrays, all within one texture.

:texture-2d-array
Gpu-Arrays in this texture all are 2-dimensional. However, it contains
multiple sets of 2-dimensional gpu-arrays, all within one texture.

:texture-cube-map-array
Gpu-Arrays in this texture are all cube maps. It contains multiple sets of
cube maps, all within one texture.

:texture-2d-multisample &amp; :texture-2d-multisample-array
Not currently supported in CEPL
</code></pre> <p><strong>-- Element Types --</strong></p> <p>Unlike <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> and <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s (which use foreign types for their elements)
textures have a different set of acceptable format. These are called
'image formats'.</p> <p>The name may imply that these formats are only usable for image data but this
is not the case. Most of the types we are used to are there, but under unsual
names.</p> <p>This would make this a ripe candidate for CEPL to clean up the naming.. but it
doesnt, why?</p> <p>Well the answer to that is image-formats are damn confusing and if we change
too much of the naming it will be even more confusing when trying to google
information. Instead CEPL provides a number of functions for converting
between (foreign) lisp types and their image-format counterparts.</p> <p><strong>-- Mip Maps --</strong></p> <p>When a texture is applied to a surface, the number of the texture's
pixels (commonly called 'texels') that are used depends on the angle at which
that surface is rendered. For example if we were rendering a TV then when it is
almost side on we will use much less pixels that if we were rendering it from
the front. At that point the gpu has to pick which texels from the texture to
use.
When an object is moving (or the camera is) the texels that are chosen to be
drawn each frame will not be the same, this causes nasty visual artifacts.</p> <p>To get around this, gpus employ mip maps. These are pre-shrunk versions of the
full-sized <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>. Each mipmap is half the size of the previous one in the
chain. So a 64x16 2D texture can have 6 mip-maps: 32x8, 16x4, 8x2, 4x1,
2x1, and 1x1.</p> <p>OpenGL does not require that the entire mipmap chain is complete; you can
specify what range of mipmaps in a texture are available.</p> <p>Some texture types have multiple independent sets of mipmaps. Each face of a
cubemap has its own set of mipmaps, as does each entry in an array texture.</p> <p>When sampling a texture (see below), the implementation will automatically
select which mipmap to use based on the viewing angle, size of texture,
and various other factors.</p> <p><strong>-- Mutable or Immutable Storage --</strong></p> <p>First we will explain what this is not, this is not about whether you can change
the contents of the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s after the texture is created. It is about whether
you can redefine the 'nature' of the data stored in the gpu-arrays after they
are created, by that we mean things like the type of the data, the resolution of
the gpu-arrays.</p> <p>It is hard to do without creating an 'incomplete' texture [1] and so CEPL opts
to treat all textures as immutable textures. When the OpenGL version doesnt
support immutable texture storage CEPL makes uses immutable storage,
allocates all the memory at construction, and doesnt provide abstractions over
the opengl features that would modify the storage.</p> <p><strong>-- Sampling --</strong></p> <p>Sampling is the process of fetching a value from a texture at a given position.
It is interesting as, because of things like mipmaping, the usual case is that
reading a single value from a texture involves reading from more than one of
its gpu-arrays and combining the resultson some fashion.</p> <p>To control this process GL (and thus CEPL) have a special object called a
sampler. Samplers have a number of values that can be tweaked that affect how
the sampling is done.</p> <p>To find out more see the cepl.samplers section.</p> <p>[0] - more correctly the default-fbo</p> <p>[1] - <a href="https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness">glwiki: texture completeness</a></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-BASE-DIMENSIONS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-BASE-DIMENSIONS">TEXTURE-BASE-DIMENSIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the resolution of the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> at the 'base-level' of the mipmap chain.
The base level is the largest one.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-CUBES-P"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-CUBES-P">TEXTURE-CUBES-P</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns t if the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> is a cube texture and nil otherwise</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-ID"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-ID">TEXTURE-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the id of the GL Texture Object from the CEPL <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>Don't use this unless you know what you are doing on the GL side.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-LAYER-COUNT"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-LAYER-COUNT">TEXTURE-LAYER-COUNT</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>When called with a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> with one of the following texture-types:
:texture-1d-array
:texture-2d-array
:texture-cube-map-array</p> <p>then this function returns the number of 'layers' in the texture.</p> <p>For all other texture types this will return 0</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-MIPMAP-LEVELS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-MIPMAP-LEVELS">TEXTURE-MIPMAP-LEVELS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>When called with a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> with mipmaps enabled this function returns the number
of 'mipmap levels' in the texture.</p> <p>For all other texture types this will return 0</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-MUTABLE-P"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-MUTABLE-P">TEXTURE-MUTABLE-P</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>When called with a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> this function returns t if the texture was made with
mutable texture storage and nil otherwise.</p> <p>Using immutable texture storage does not mean that the data inside the texture's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s cannot be mutated.</p> <p>Mutable texture storage allows you to redefine the 'nature' of the data stored
in the gpu-arrays after they are created, by that we mean things like the type
of the data, the resolution of the gpu-arrays.</p> <p>As it is hard to change such things without creating an 'incomplete' texture[0]
CEPL opts to treat all textures as immutable textures.
When the OpenGL version doesnt support immutable texture storage CEPL makes uses
immutable storage, allocates all the memory at construction, and doesnt provide
abstractions over the opengl features that would modify the storage.</p> <p>[0] - https://www.opengl.org/wiki/Immutable_Storage_Texture#Texture_completeness</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-TYPE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-TYPE">TEXTURE-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function will return the type of the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>The possible values are:</p> <pre><code>:texture-1d
:texture-2d
:texture-3d
:texture-rectangle
:texture-buffer
:texture-cube-map
:texture-1d-array
:texture-2d-array
:texture-cube-map-array
:texture-2d-multisample
:texture-2d-multisample-array
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:BUFFER-TEXTURE-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:BUFFER-TEXTURE-P">BUFFER-TEXTURE-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Return t if the given value is a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> who data is stored in a <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> as
opposed to the usual texture memory. Returns nil otherwise</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:GENERATE-MIPMAPS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:GENERATE-MIPMAPS">GENERATE-MIPMAPS</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Calling this with a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> asks OpenGL to generate mipmaps for the texture.</p> <p>You do not normally need to use this function as you can use the :mipmaps
argument on <code><a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a></code>. See <code><a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a></code> for more details.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:MAKE-TEXTURE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:MAKE-TEXTURE">MAKE-TEXTURE</a> </code> <code class="qualifiers"></code> <code class="arguments">INITIAL-CONTENTS &amp;KEY DIMENSIONS ELEMENT-TYPE (MIPMAP NIL) (LAYER-COUNT 1)
 (CUBES NIL) (RECTANGLE NIL) (MULTISAMPLE NIL) (IMMUTABLE T)
 (BUFFER-STORAGE NIL) (GENERATE-MIPMAPS T) PIXEL-FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function allows you to make any kind of <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> based on the arguments
provided. Whilst the signature is quite intimidating your rarely need to use
more than a few of the arguments to make a given texture.</p> <p>For example:</p> <pre><code>(<a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a> '(1 2 3 4))
</code></pre> <p>will give you a valid texture.</p> <p>We will now go through the arguments and their behaviours:</p> <p><strong>-- :initial-contents :dimensions &amp; :element-type --</strong></p> <ul> <li><p>with :initial-contents to nil:
  In this case you need to provide dimensions and an element-type.</p></li> <li><p>with :initial-contents populated.
  The initial-contents can be a (potentially nested) list, array or <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p></li> </ul> <p>When the :initial-contents are a c-array then the dimensions and element-type
are taken from the c-array. As the data is already in foreign memory the
upload will be notable faster that from lisp-data-&gt;gpu as no type conversions
are needed</p> <p>When the :initial-contents are an array then the dimension of the texture
will be the same as the array passed in. Remember OpenGL only allows up to
3 dimensions for the textures</p> <p>When the :initial-contents is a flat list then each element is used as one
element in the textures <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code></p> <p>If the :initial-contents is a nested list then you must either:</p> <ul> <li>specify multiple dimensions and an element-type</li> <li>specify an element-type to be some struct type, then nested lists are then
  used to populate the fields of the foreign structs. For an example of this
  please see this example: https://github.com/cbaggers/cepl.examples/blob/master/examples/triangle.lisp#L30.</li> </ul> <p>If the :element-type is not provided then CEPL will look at every element in
the initial-contents and try and find the smallest (in bytes) foreign type
which works for every element. This mean if the array is full of single-floats
then CEPL will choose :float, not :double.
Naturally this behaviour is too slow for use in performance critical
applications however it is nice for experimentation and working from the repl.</p> <p>Extra element-type details:
Unlike c-array and gpu-arrays (which use foreign types for their elements)
textures have a different set of acceptable element-types. These are called
'image formats'.</p> <p>If you provide a GL image-format as the :element-type CEPL will use it directly</p> <p>If you provide a (foreign) lisp type then CEPL will try to find the appropriate
image-format for that type.</p> <p><strong>-- :pixel-format --</strong></p> <p>If this optional argument is not nil, then CEPL will use the pixel format
provided when uploading the pixel data.</p> <p>Usually this is not provided as CEPL can calculate a valid pixel-format to
use from the element-type.</p> <p><strong>-- :mipmap &amp; :generate-mipmaps --</strong></p> <p>If this is set to t then CEPL will make mipmaps for the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>. The texture
will have (floor (log (apply #'max dimensions) 2)) levels of mipmaps</p> <p>If this is set to a positive integer CEPL will check that the number of levels
is allowed for the dimensions given and make that many levels of mipmaps.</p> <p>If generate-mipmaps is t CEPL will ask OpenGL to generate content for all the
mipmaps levels.</p> <p><strong>-- :layer-count --</strong></p> <p>If this is set to a value greater than 1 then you are trying to create one of
the following:</p> <p>:texture-1d-array
:texture-2d-array
:texture-cube-map-array</p> <p>Which one is created depends on the dimensions provided and whether cubes is t.</p> <p><strong>-- :cubes --</strong></p> <p>If this is t then you are trying to make a cube-map texture</p> <p><strong>-- :rectangle --</strong></p> <p>If this is t then you are trying to make a rectangle texture.</p> <p>This is different from a regular 2d texture (which can also be rectangular)</p> <p>This texture only has one 2-dimensional <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>. The texture cannot have
mipmapping. Texture coordinates used for these textures are not normalized.</p> <p><strong>-- :multisample --</strong></p> <p>This is not currently supported in CEPL</p> <p><strong>-- :immutable --</strong></p> <p>Set this to nil if you definitely dont want to use immutable texture storage.
See the docstring for 'texture for more details</p> <p><strong>-- :buffer-storage --</strong></p> <p>If this is set to t you are trying to make a <code><a href="#CEPL.TEXTURES:BUFFER-TEXTURE">buffer-texture</a></code>.</p> <p>If you set this to t then the <code><a href="#CEPL.C-ARRAYS:ELEMENT-TYPE">element-type</a></code> should NOT be an image-format. Use
a foreign lisp type instead. Or leave it nil if you want CEPL to take the type
from the initial-contents</p> <p>See the docstring for <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> for more details.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:MAKE-TEXTURE-FROM-ID"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:MAKE-TEXTURE-FROM-ID">MAKE-TEXTURE-FROM-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">GL-OBJECT &amp;KEY BASE-DIMENSIONS TEXTURE-TYPE ELEMENT-TYPE MIPMAP-LEVELS
 LAYER-COUNT CUBES ALLOCATED MUTABLE-P</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Wrap and existing GL Texture Object in a CEPL <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> struct.</p> <p>This function does not do ANY sanity checking on the values provided, use only
if you are 100% sure of what you are setting.</p> <p>For details on the meaning of the arguments see the docstring for <code><a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXREF"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXREF">TEXREF</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE &amp;KEY (MIPMAP-LEVEL 0) (LAYER 0) (CUBE-FACE 0)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function allows you to access a specific <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> from the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>:mipmap-level is invalid if the texture doesnt have mipmaps</p> <p>:layer is invalid if the texture-type is not a 1d,2d or cube-map array-texture.</p> <p>:cube-face is invalid if the texture is not a cube-map texture</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-ELEMENT-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-ELEMENT-TYPE">TEXTURE-ELEMENT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns the element-type of the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>If the texture is a <code><a href="#CEPL.TEXTURES:BUFFER-TEXTURE">buffer-texture</a></code> then the element-type will be a foreign lisp
type.</p> <p>Otherwise it will be one of the image-formats</p> <p><strong>-- Element Types Details --</strong></p> <p>Unlike <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> and <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s (which use foreign types for their elements)
textures have a different set of acceptable format. These are called
'image formats'.</p> <p>The name may imply that these formats are only usable for image data but this
is not the case. Most of the types we are used to are there, but under unsual
names.</p> <p>This would make this a ripe candidate for CEPL to clean up the naming.. but it
doesnt, why?</p> <p>Well the answer to that is image-formats are damn confusing and if we change
too much of the naming it will be even more confusing when trying to google
information. Instead CEPL provides a number of functions for converting
between (foreign) lisp types and their image-format counterparts.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:TEXTURE-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:TEXTURE-P">TEXTURE-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the given value is a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>, otherwise nil is
returned.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:FREE-TEXTURE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:FREE-TEXTURE">FREE-TEXTURE</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function will free the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> and all texture-memory behind the texture's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s.</p> <p>Be sure not to use those arrays after this function has been called.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TEXTURES:WITH-TEXTURE-BOUND"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TEXTURES:WITH-TEXTURE-BOUND">WITH-TEXTURE-BOUND</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>Binds the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> to the <code>gl-context</code> for the duration of the body and then
ensures it is unbound.</p> <p>You do not need to interact with this directly as it will be handled
by <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> and the <code>pipeline</code> itself.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.SAMPLERS" href="#CEPL.SAMPLERS">CEPL.SAMPLERS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLER"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.SAMPLERS:SAMPLER">SAMPLER</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><i>No docstring provided.</i></div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLER"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.SAMPLERS:SAMPLER">SAMPLER</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>As <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> is a structure which we pass to the a gpu-pipeline to specify how the
pipeline should read from a particular <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> (also known as sampling the
texture).</p> <p>They are created by calling <code><a href="#CEPL.SAMPLERS:SAMPLE">sample</a></code> on a texture. You can then modify the
various parameters and the pass the sampler to a pipeline as a uniform.</p> <p>Sampling Parameters cover four main aspects of how the values are read:</p> <ul> <li>Wrapping</li> <li>Filtering</li> <li>LOD</li> <li>Comparison</li> </ul> <p>We will dive into these topics below.</p> <p><strong>-- Note for beginners --</strong></p> <p>This area of GL can be incredibly confusing so don't worry if you don't grasp
it immediately. Lots can be done without messing with these values, tackle each
one when you have a usecase for it.</p> <p><strong>-- Wrapping --</strong></p> <p>When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.</p> <p>However normalized texture coordinates are not limited to values between
0s0 and 1s0. They can be any floating-point number.</p> <p>When a texture coordinate is not within the 0 → 1 range, some means must be
employed to decide what the color value will be.</p> <p>The different approaches are as follows:</p> <pre><code>:repeat: the texture coordinate wraps around the texture. so a texture
         coordinate of -0.2 becomes the equivalent of 0.8.

:mirrored-repeat: the texture coordinate wraps around like a mirror.
                  -0.2 becomes 0.2, -1.2 becomes 0.8, etc.

:clamp-to-edge: the texture coordinate is clamped to the 0 → 1 range.

:clamp-to-border: the texture coordinate is clamped to the 0 → 1
                  range, but the edge texels are blended with a
                  constant border color.

:mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                       :arb-texture-mirror-clamp-to-edge) the texture
                       is clamped to the -1 → 1 range, but mirrors the
                       negative direction with the positive. Basically,
                       it acts as :clamp-to-edge, except that it
                       takes the absolute value of the texture
                       coordinates before clamping.
</code></pre> <p>This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not
the normalized 0 → 1 range.</p> <p>This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:WRAP">wrap</a> texture-or-sampler)
      #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))

(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:WRAP">wrap</a> texture-or-sampler) :clamp-to-edge)
</code></pre> <p><strong>-- Filtering --</strong></p> <p>Filtering is the process of accessing a particular sample from a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>.</p> <p>There are two cases when filtering is relevant: minification and magnification.</p> <p>Magnification means that the area of the fragment in texture space is smaller
than a texel, and minification means that the area of the fragment in texture
space is larger than a texel.</p> <p>Filtering for these two cases can be set independently.</p> <p>The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.</p> <p>If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').</p> <p>If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAGNIFY-FILTER">magnify-filter</a> tex-or-sampler) :linear)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAGNIFY-FILTER">magnify-filter</a> tex-or-sampler) :nearest)
</code></pre> <p>The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:</p> <pre><code>:nearest                 :linear
:nearest-mipmap-nearest  :nearest-mipmap-linear
:linear-mipmap-nearest   :linear-mipmap-linear
</code></pre> <p>When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.</p> <p>The OpenGL minification settings for these are as follows:</p> <pre><code>Param Setting            Lin within mip-level
:nearest                 No
:linear                  Yes
:nearest-mipmap-nearest  No
:linear-mipmap-nearest   Yes
:nearest-mipmap-linear   No
:linear-mipmap-linear    Yes

Param Setting            Has mipmapping
:nearest                 No
:linear                  No
:nearest-mipmap-nearest  Yes
:linear-mipmap-nearest   Yes
:nearest-mipmap-linear   Yes
:linear-mipmap-linear    Yes

Param Setting            Linear between mip-levels
:nearest                 -
:linear                  -
:nearest-mipmap-nearest  No
:linear-mipmap-nearest   No
:nearest-mipmap-linear   Yes
:linear-mipmap-linear    Yes
</code></pre> <p>Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details</p> <p>examples:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MINIFY-FILTER">minify-filter</a> tex-or-sampler) :linear)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MINIFY-FILTER">minify-filter</a> tex-or-sampler) :nearest-mipmap-nearest)
(setf-minify-filter tex-or-sampler :nearest :nearest)
</code></pre> <p><strong>-- LOD --</strong></p> <p>There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).</p> <p>The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MIN-LOD">min-lod</a> texture-or-sampler) value)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAX-LOD">max-lod</a> texture-or-sampler) value)
</code></pre> <p>LOD bias:
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap
LOD calculation (as well as added to the bias specified in one of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:LOD-BIAS">lod-bias</a> texture-or-sampler) value)
</code></pre> <p><strong>-- Comparison --</strong></p> <p>-WARNING-</p> <p>This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk</p> <p>Depth <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.</p> <p>They can also be fetched in comparison mode. This means that sampling from
the texture requires a value to compare to those pulled from the texture;
this value is called the reference value. The result of the comparison
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.</p> <p>When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0 → 1 and
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.</p> <p>If the texture is a normalized integer depth format, then the reference value
is clamped to 0 → 1, to match the values from the texture. Otherwise, the value
is not clamped.</p> <p>Using this mode requires two special settings. First, the <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.</p> <p>To set the texture to comparison mode, set the :texture-compare-mode
texture parameter to :compare-ref-to-texture. The comparison function to
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:</p> <pre><code>:never (always fails)
:always (always succeeds)
:less
:lequal
:equal,
:not-equal
:gequal
:greater
</code></pre> <p>The comparison works as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/funcall">funcall</a> operator ref texture)
</code></pre> <p>Where ref is the reference value given to the texture lookup function by
GLSL, and texture is the value fetched from the texture. So :LESS will be
true if the reference value is strictly less than the value pulled from the
texture.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:COMPARE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:COMPARE">COMPARE</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function sets the comparison mode of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> given</p> <p>-WARNING-</p> <p>This feature is currently unsupported until shadow samplers are more fully
tested in CEPL. Use at your own risk</p> <p><strong>-- Comparison --</strong></p> <p>Depth <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>s (textures that have a depth component image format) can be
sampled in one of two ways. They can be sampled as a normal texture, which
simply retrieves the depth value (with filtering applied). This will return a
vec4 containing a single floating-point value.</p> <p>They can also be fetched in comparison mode. This means that sampling from
the texture requires a value to compare to those pulled from the texture;
this value is called the reference value. The result of the comparison
depends on the comparison function set in the texture. If the function
succeeds, the resulting value is 1s0; if it fails, it is 0s0.</p> <p>When linear filtering is used, the actual returned value is
implementation-defined. However, the value will be on the range 0 → 1 and
will be proportional to the number of neighboring texels that pass the
comparison based on the single given value.</p> <p>If the texture is a normalized integer depth format, then the reference value
is clamped to 0 → 1, to match the values from the texture. Otherwise, the value
is not clamped.</p> <p>Using this mode requires two special settings. First, the sampler used in GLSL
must be a shadow sampler. Second, the texture used in that sampler must have
activated depth comparison mode. Attempting to use a texture without comparison
with a shadow sampler, or vice-versa, will result in an error upon rendering.</p> <p>To set the texture to comparison mode, set the :texture-compare-mode
texture parameter to :compare-ref-to-texture. The comparison function to
use when comparing the reference to the texture is set with the
:texture-compare-func texture parameter. Acceptable values are:</p> <pre><code>:never (always fails)
:always (always succeeds)
:less
:lequal
:equal,
:not-equal
:gequal
:greater
</code></pre> <p>The comparison works as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/funcall">funcall</a> operator ref texture)
</code></pre> <p>where ref is the reference value given to the texture lookup function by
GLSL, and texture is the value fetched from the texture. So :LESS will be
true if the reference value is strictly less than the value pulled from the
texture.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:LOD-BIAS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:LOD-BIAS">LOD-BIAS</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function sets the lod-bias of the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code></p> <p><strong>-- LOD --</strong></p> <p>There is a pair of sampling parameters that affect the mipmap image selection:
:max-lod and :min-lod (floating-point values).</p> <p>The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MIN-LOD">min-lod</a> texture-or-sampler) value)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAX-LOD">max-lod</a> texture-or-sampler) value)
</code></pre> <p>LOD bias:
The mipmap image selection process can be adjusted coarsely by using the
:lod-bias sampling parameter. This bias will be added to the mipmap
LOD calculation (as well as added to the bias specified in one of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> accessing functions in GLSL), which is used to select the image. A positive bias
means that larger mipmaps will be selected even when the texture is viewed from
farther away. This can cause visual aliasing, but in small quantities it can
make textures a bit more sharp.</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:LOD-BIAS">lod-bias</a> texture-or-sampler) value)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:MAGNIFY-FILTER"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:MAGNIFY-FILTER">MAGNIFY-FILTER</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> or <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> and sets the approach used when the
area of the fragment in texture space is smaller than a texel.</p> <p><strong>-- The magnification filter --</strong></p> <p>The magnification filter is controlled by the :magnify-filter texture parameter.
This value can be :linear or :nearest.</p> <p>If :nearest is used, then the implementation will select the texel nearest the
texture coordinate; this is commonly called 'point sampling').</p> <p>If :linear is used, the implementation will perform a weighted linear blend
between the nearest adjacent samples.</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAGNIFY-FILTER">magnify-filter</a> tex-or-sampler) :linear)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAGNIFY-FILTER">magnify-filter</a> tex-or-sampler) :nearest)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:MAX-LOD"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:MAX-LOD">MAX-LOD</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function sets the max-lod of the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code></p> <p><strong>-- LOD --</strong></p> <p>Together with :min-lod this sampling parameter affects the mipmap image
selection.</p> <p>The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MIN-LOD">min-lod</a> texture-or-sampler) value)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAX-LOD">max-lod</a> texture-or-sampler) value)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:MIN-LOD"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:MIN-LOD">MIN-LOD</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function sets the min-lod of the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code></p> <p><strong>-- LOD --</strong></p> <p>Together with :max-lod this sampling parameter affects the mipmap image
selection.</p> <p>The way these work in mipmap selection is quite complicated; the specification
goes into full detail about it.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MIN-LOD">min-lod</a> texture-or-sampler) value)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MAX-LOD">max-lod</a> texture-or-sampler) value)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:MINIFY-FILTER"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:MINIFY-FILTER">MINIFY-FILTER</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> or <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> and sets the approach used when the
area of the fragment in texture space is larger than a texel.</p> <p><strong>-- The minification filter --</strong></p> <p>The minification filter is controlled by the :texture-min-filter texture
parameter. To understand these values better, it is important to discuss what
the particular options are. Here is the full list:</p> <pre><code>:nearest                 :linear
:nearest-mipmap-nearest  :nearest-mipmap-linear
:linear-mipmap-nearest   :linear-mipmap-linear
</code></pre> <p>When doing minification, you can choose to use mipmapping or not. Using
mipmapping means selecting between multiple mipmaps based on the angle and size
of the texture relative to the screen. Whether you use mipmapping or not,
you can still select between linear blending of the particular layer or nearest.
And if you do use mipmapping, you can choose to either select a single mipmap to
sample from, or you can sample the two adjacent mipmaps and linearly blend the
resulting values to get the final result.</p> <pre><code>The OpenGL minification settings for these are as follows:
Param Setting            Lin within mip-level
:nearest                 No
:linear                  Yes
:nearest-mipmap-nearest  No
:linear-mipmap-nearest   Yes
:nearest-mipmap-linear   No
:linear-mipmap-linear    Yes

Param Setting            Has mipmapping
:nearest                 No
:linear                  No
:nearest-mipmap-nearest  Yes
:linear-mipmap-nearest   Yes
:nearest-mipmap-linear   Yes
:linear-mipmap-linear    Yes

Param Setting            Linear between mip-levels
:nearest                 -
:linear                  -
:nearest-mipmap-nearest  No
:linear-mipmap-nearest   No
:nearest-mipmap-linear   Yes
:linear-mipmap-linear    Yes
</code></pre> <p>Remembering these combinations can be annoying so CEPL provides an additional
function called #'set-minify-filter see the docstring for details</p> <p>examples:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MINIFY-FILTER">minify-filter</a> tex-or-sampler) :linear)
(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:MINIFY-FILTER">minify-filter</a> tex-or-sampler) :nearest-mipmap-nearest)
(setf-minify-filter tex-or-sampler :nearest :nearest)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:WRAP"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:WRAP">WRAP</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function sets the wrap parameter of the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> given.</p> <p>When setf'ing this parameter you can provide either one approach to be used
for all 3 potential dimensions of the texture, or you can provide a vector
of the 3 approaches you want to used.</p> <p><strong>-- Wrapping --</strong></p> <p>When using normalized texture coordinates we are used to thinking about our
coordinate being between 0s0 and 1s0 and that value dictating where we are
sampling from.</p> <p>However normalized texture coordinates are not limited to values between
0s0 and 1s0. They can be any floating-point number.</p> <p>When a texture coordinate is not within the 0 → 1 range, some means must be
employed to decide what the color value will be.</p> <p>The different approaches are as follows:</p> <pre><code>:repeat: the texture coordinate wraps around the texture. so a texture
         coordinate of -0.2 becomes the equivalent of 0.8.

:mirrored-repeat: the texture coordinate wraps around like a mirror.
                  -0.2 becomes 0.2, -1.2 becomes 0.8, etc.

:clamp-to-edge: the texture coordinate is clamped to the 0 → 1 range.

:clamp-to-border: the texture coordinate is clamped to the 0 → 1
                  range, but the edge texels are blended with a
                  constant border color.

:mirror-clamp-to-edge: (only available with OpenGL 4.4 or
                       :arb-texture-mirror-clamp-to-edge) the texture
                       is clamped to the -1 → 1 range, but mirrors the
                       negative direction with the positive. Basically,
                       it acts as :clamp-to-edge, except that it
                       takes the absolute value of the texture
                       coordinates before clamping.
</code></pre> <p>This also applies to Rectangle Textures, except that the range at which they
apply edge sampling is based on the texel width/height of the texture, not
the normalized 0 → 1 range.</p> <p>This does not apply to Buffer Textures, as they must use the texelFetch sampling
functions and thus cannot sample outside of the texel range of the texture.</p> <p>example:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:WRAP">wrap</a> texture-or-sampler)
      #(:clamp-to-edge :repeat-to-edge :clamp-to-edge))

(<a href="http://l1sp.org/cl/setf">setf</a> (<a href="#CEPL.SAMPLERS:WRAP">wrap</a> texture-or-sampler) :clamp-to-edge)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:FREE-SAMPLER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:FREE-SAMPLER">FREE-SAMPLER</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Calling this with a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> will free the gl sampler and blank the lisp object representing it.</p> <p>Calling the generic function <code><a href="#CEPL.MEMORY:FREE">free</a></code> with a sampler will call this function</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:SAMPLE">SAMPLE</a> </code> <code class="qualifiers"></code> <code class="arguments">TEXTURE &amp;KEY (LOD-BIAS 0.0) (MIN-LOD -1000.0) (MAX-LOD 1000.0)
 (MINIFY-FILTER :LINEAR-MIPMAP-LINEAR) (MAGNIFY-FILTER :LINEAR)
 (WRAP #(:REPEAT :REPEAT :REPEAT)) (COMPARE :NONE)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> and optionally some sampling parameters and
returns a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code>.</p> <p>The sampler is an object that is passed to a pipeline so that the shaders in
the gpu-functions in the pipeline can read from the gpu-arrays in the texture.</p> <p>For details on what the parameters are and mean see the docstring for the
'sampler type</p> <p><strong>-- Note about GL Versions --</strong></p> <p>Sampler Objects were introduced in GL 3.3. So for now CEPL needs at least v3.3
in future we hope to lower the requirement to 3.1 but this will take some extra
work.</p> <p><strong>-- NOTE For those with GL experience --</strong></p> <p>You will have noticed that in CEPL your sampler is tied to one texture which is
unlike in regular GL where a sample object can be used to override the sampling
parameters of any number of textures. At first this would seem very wasteful
however CEPL does not use 1 GL Sampler Object per CEPL sampler. The ID sharing
is done based on the parameters.</p> <p>This means you get the same number of sampler objects as your would normally
but with the added benefit that samplers are semantically dual with buffer-streams
giving greater api consistancy.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLER-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:SAMPLER-P">SAMPLER-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the supplied value is a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> and nil otherwise</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLER-TEXTURE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:SAMPLER-TEXTURE">SAMPLER-TEXTURE</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> as its only argument and returns the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> being sampled by the sampler.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SAMPLER-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:SAMPLER-TYPE">SAMPLER-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> as its only argument and returns the kind
of sampler it is.</p> <p>The result will be one of the kinds listed in cepl.samplers::<em>sampler-types</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:SET-MINIFY-FILTER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:SET-MINIFY-FILTER">SET-MINIFY-FILTER</a> </code> <code class="qualifiers"></code> <code class="arguments">SAMPLER FOR-LEVEL &amp;KEY (BETWEEN-LEVELS NIL)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>As the naming of the values for #'minify-filter are quite confusing this
function allows you to set the minify filter for the given <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> or <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> based on the following:</p> <ul> <li><p>for-level: what sampling should be used between texels on the current
         mipmap level. The value can be :linear or :nearest</p></li> <li><p>between-level: what sampling should be used between texels on different
             mipmap levels. The value can be :linear or :nearest
             This argument is optional.</p></li> </ul> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.SAMPLERS:WITH-SAMPLING"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.SAMPLERS:WITH-SAMPLING">WITH-SAMPLING</a> </code> <code class="qualifiers"></code> <code class="arguments">(VAR TEX) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro takes a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> and creates a temporary <code><a href="#CEPL.SAMPLERS:SAMPLER">sampler</a></code> that is valid
within the scope.</p> <p>As the sampler will be freed at the end of the scope, do not return it or
assign it to any variable that outlasts the scope.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.MEMORY" href="#CEPL.MEMORY">CEPL.MEMORY</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.MEMORY:FREE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEMORY:FREE">FREE</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>The function takes a CEPL object of any one of the following types.</p> <ul> <li><code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code></li> <li><code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code></li> <li><code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> (texture backed or buffer backed)</li> <li><code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code></li> <li><code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code></li> <li><code><a href="#CEPL.UBOS:UBO">ubo</a></code></li> <li><code><a href="#CEPL.FBOS:FBO">fbo</a></code></li> </ul> <p>And deletes the internal GL object, frees any associated memory and blanks the
CEPL object.</p> <p>'Blanking', in this case, means the fields of the object will be set to some
default.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.MEMORY:INITIALIZED-P"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEMORY:INITIALIZED-P">INITIALIZED-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>When given an object holding a gpu resource this function will return whether
that object has been initialized.</p> <p>This will be t unless the GL context has not yet been created.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.MEMORY:PULL-G"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEMORY:PULL-G">PULL-G</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function takes a CEPL object containing foreign or gpu data as pulls the
data into lisp performing any data conversions that are required on the way.</p> <p>CEPL types that can be pulled from are:
- <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> - <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> (both texture-backed and buffer-backed)
- <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> - <code><a href="#CEPL.UBOS:UBO">ubo</a></code> - Any instance of a type defined using <code><a href="#CEPL.TYPES:DEFSTRUCT-G">defstruct-g</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.MEMORY:PULL1-G"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEMORY:PULL1-G">PULL1-G</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function is a varient of <code><a href="#CEPL.MEMORY:PULL-G">pull-g</a></code> which, rather than pulling the gpu or
foreign data to lisp, will instead pull it 1 level closer to lisp.</p> <p>What is meant by that is that, if the data is in foreign memory then it will be
pulled to lisp data (just like <code><a href="#CEPL.MEMORY:PULL-G">pull-g</a></code>). However if you call <code><a href="#CEPL.MEMORY:PULL1-G">pull1-g</a></code> on data
stored on the gpu, then the data will be pulled to foreign memory instead.</p> <p>To clarify:</p> <pre><code>(<a href="#CEPL.MEMORY:PULL1-G">pull1-g</a> c-array) -&gt; lisp list
(<a href="#CEPL.MEMORY:PULL1-G">pull1-g</a> gpu-array) -&gt; c-array
</code></pre> <p>You can use pull1-g on the following CEPL types.
- <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> - <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> (both texture-backed and buffer-backed)
- <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> - <code><a href="#CEPL.UBOS:UBO">ubo</a></code> - Any instance of a type defined using <code><a href="#CEPL.TYPES:DEFSTRUCT-G">defstruct-g</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.MEMORY:PUSH-G"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEMORY:PUSH-G">PUSH-G</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT DESTINATION</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function takes a CEPL object as a desination and some data to push to the
desination.</p> <p>It will then upload that data to the destination doing any data conversions
that are required on the way.</p> <p>CEPL types supported as destinations are:
- <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> - <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> (both texture-backed and buffer-backed)
- <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> - <code><a href="#CEPL.UBOS:UBO">ubo</a></code> - Any instance of a type defined using <code><a href="#CEPL.TYPES:DEFSTRUCT-G">defstruct-g</a></code></p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.MEASUREMENTS" href="#CEPL.MEASUREMENTS">CEPL.MEASUREMENTS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.MEASUREMENTS:DIMENSIONS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEASUREMENTS:DIMENSIONS">DIMENSIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the list containing the dimensions of the given value</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.MEASUREMENTS:RESOLUTION"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.MEASUREMENTS:RESOLUTION">RESOLUTION</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the resolution of the given value as a vec*</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.FBOS" href="#CEPL.FBOS">CEPL.FBOS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.FBOS:FBO"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.FBOS:FBO">FBO</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>A framebuffer object (<code><a href="#CEPL.FBOS:FBO">FBO</a></code>) is a structure that can be rendered into.</p> <p>When a FBO is rendered into the data from the pipeline is written into one or
more of the <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>s of the FBO</p> <p>An FBO attachment is a slot where a texture-backed <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> can be attached.
When the gpu-array is attached the data from a pipeline rendering into the fbo
is written into that gpu-array.</p> <p>This is the heart of how multi-pass rendering is done in OpenGL. One pipeline
writes data into <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>s that are then used as inputs to another pipeline[0].</p> <p>A FBO can have:
- 0 or more 'color attachments'
- 0 or 1 'depth attachment'
- 0 or 1 'stencil attachment'
- 0 or 1 'depth-stencil attachment'</p> <p>Let's look at these in more detail:</p> <p><strong>-- Color Attachments --</strong></p> <p>Color attachments can only contain gpu-arrays whose element-type can be found in
the <em>color-renderable-formats</em> list.</p> <p>Note that while OpenGL terminology mentions 'color' and 'image' a lot you are
not limitted to only using textures or fbos for pictures. It is perfectly
valid (and incredibly useful) to return data meaning all kinds of things other
than colors.</p> <p><strong>-- Depth Attachments --</strong></p> <p>The depth attachment (when used) can only contain a gpu-array whos element-type
can be found in <em>depth-formats</em></p> <p><em>Usage Tip:</em> Even if you don't plan on reading from this depth_attachment, any
fbo that will be rendered to should have a depth attachment.</p> <p><strong>-- Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --</strong></p> <p>The stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in <em>stencil-formats</em></p> <p><strong>-- Depth-Stencil Attachments (NOT SUPPORTED IN CURRENT CEPL VERSION) --</strong></p> <p>The depth-stencil attachment (when used) can only contain a gpu-array whos
element-type can be found in <em>depth-stencil-formats</em></p> <p>This attachment is shorthand for 'both depth and stencil'. The gpu-array
attached here becomes both the depth and stencil attachment.</p> <p><strong>-- Choosing which attachment to render into --</strong></p> <p>Making these choices is done with the <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code> macro. See its docstring
for further details</p> <p>[0] WARNING:</p> <p>It is possible to bind a texture to an FBO, bind that same texture to a shader,
and then try to sample from it at the same time. You will get undefined results.</p> <p>This means it may do what you want, the sampler may get old data, the sampler
may get half old and half new data, or it may get garbage data. Any of these are
possible outcomes.</p> <p>Do Not Do This!</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:ATTACHMENT"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:ATTACHMENT">ATTACHMENT</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function retrieves the <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code> named by attachment-name from the
given <code><a href="#CEPL.FBOS:FBO">fbo</a></code>. The result is a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code></p> <p>The attachment-name can be one of the following:</p> <p>a positive integer - In which case this function returns the
                      nth color-attachments where (= n attachment-name)</p> <p>:d - the depth-attachment is returned</p> <p>:s - the stencil-attachment is returned [0]</p> <p>:ds - the depth-stencil-attachment is returned [0]</p> <p>You can also setf this function, the value must be a texture-backed gpu-array
with a valid element-type for that attachment.</p> <p>For color attachments this means the element type must be a member of
the <code><a href="#CEPL.IMAGE-FORMATS:*COLOR-RENDERABLE-FORMATS*">*color-renderable-formats*</a></code> list</p> <p>For color attachments this means the element type must be a member of
the <code><a href="#CEPL.IMAGE-FORMATS:*DEPTH-FORMATS*">*depth-formats*</a></code> list</p> <p>For stencil attachments this means the element type must be a member of
the <code><a href="#CEPL.IMAGE-FORMATS:*STENCIL-FORMATS*">*stencil-formats*</a></code> list</p> <p>For depth-stencil attachments this means the element type must be a member of
the <code><a href="#CEPL.IMAGE-FORMATS:*DEPTH-STENCIL-FORMATS*">*depth-stencil-formats*</a></code> list</p> <p>[0] <em>WARNING:</em> :s &amp; :ds are not supported in the current version of CEPL</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:ATTACHMENT-BLENDING"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:ATTACHMENT-BLENDING">ATTACHMENT-BLENDING</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the blending parameters that will be used when rendering
into the specified <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code> on the given <code><a href="#CEPL.FBOS:FBO">fbo</a></code></p> <p>Blending parameters tell OpenGL how values written into a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> should be
combined with any values that are already present.</p> <p>The canonical use for this is implementing transparency.</p> <p>The details of blending parameters and where they can be used is best covered in
the docstring for the <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:ATTACHMENT-TEX"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:ATTACHMENT-TEX">ATTACHMENT-TEX</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function take an <code><a href="#CEPL.FBOS:FBO">fbo</a></code> and the name of an <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>. It then returns
the <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> that backs the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> in the specified attachment.</p> <p>It is equivalent to writing:</p> <pre><code>(gpu-array-texture (<a href="#CEPL.FBOS:ATTACHMENT">attachment</a> fbo attachmnent-name))
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:ATTACHMENT-VIEWPORT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:ATTACHMENT-VIEWPORT">ATTACHMENT-VIEWPORT</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes an <code><a href="#CEPL.FBOS:FBO">fbo</a></code> and attachment-name and returns a new <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> whos
dimensionsmatch those of the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> connected to the <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:CHECK-FRAMEBUFFER-STATUS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:CHECK-FRAMEBUFFER-STATUS">CHECK-FRAMEBUFFER-STATUS</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function asks OpenGL to check the given <code><a href="#CEPL.FBOS:FBO">FBO</a></code> and ensure that it is
'complete'.</p> <p>This function will either return the particular 'framebuffer complete' flag or
will throw a condition with an explanation of the problem.</p> <p>For a full rundown on what it means for a fbo to be complete see: <a href="https://www.opengl.org/wiki/Framebuffer_Object#Framebuffer_Completeness">glwiki- framebuffer completeness</a></p> <p>All fbos made in CEPL using <code><a href="#CEPL.FBOS:MAKE-FBO">make-fbo</a></code> are checked for completeness before
being returned to the user.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:CLEAR"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:CLEAR">CLEAR</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;OPTIONAL TARGET</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>What this function will clear depends on what is passed:</p> <ul> <li>a <code><a href="#CEPL.FBOS:FBO">fbo</a></code> - See 'clearing fbos' below</li> <li>an <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code> - See 'clearing a single attachment' below</li> <li>nothing - The 'current fbo' will be cleared</li> </ul> <p><strong>-- Clearing Fbos --</strong></p> <p>In this case clearing means that all the elements of the attachments will be set
to a certain value. The value that the attachment's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s will be set to
varies based on the attachment.</p> <ul> <li>color attachments: Will be set to the value set in #'gl:clear-color</li> <li>depth attachments: Will be set to the value set in #'gl:clear-depth</li> <li>stencil attachments: Will be set to the value set in #'gl:clear-stencil</li> </ul> <p>You can also use <code><a href="#CEPL.FBOS:CLEAR-FBO">clear-fbo</a></code> for this task</p> <p><strong>-- Clearing a single attachment --</strong></p> <p>Not currently implemented</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:CLEAR-ATTACHMENT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:CLEAR-ATTACHMENT">CLEAR-ATTACHMENT</a> </code> <code class="qualifiers"></code> <code class="arguments">ATTACHMENT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Not currently implemented</p> <p>This function will clear a single <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code> of a <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:CLEAR-FBO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:CLEAR-FBO">CLEAR-FBO</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will set the elements of the <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>s of the <code><a href="#CEPL.FBOS:FBO">fbo</a></code> to a
certain value. The value that the attachment's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s will be set to
varies based on the attachment.</p> <ul> <li>color attachments: Will be set to the value set in #'gl:clear-color</li> <li>depth attachments: Will be set to the value set in #'gl:clear-depth</li> <li>stencil attachments: Will be set to the value set in #'gl:clear-stencil</li> </ul> <p>You can also perform this action by calling <code><a href="#CEPL.FBOS:CLEAR">clear</a></code> with an fbo</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:FBO-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:FBO-P">FBO-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will return t if the given value is an <code><a href="#CEPL.FBOS:FBO">fbo</a></code>, otherwise it will
return nil</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:MAKE-FBO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:MAKE-FBO">MAKE-FBO</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;REST FUZZY-ATTACH-ARGS</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This, like other make-* functions in CEPL has a large variety of valid
arguments. The goal of this apparent complexity is to make exploration from the
repl easy, whilst still allowing absolutely control when it is needed.</p> <p>Lets look at the behaviour when given different arguments</p> <p><strong>-- (make-fbo) --</strong></p> <p>It is not valid is have an <code><a href="#CEPL.FBOS:FBO">fbo</a></code> with no <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>s so this will fail</p> <p><strong>-- (make-fbo 0) --</strong></p> <p>Make an fbo with one color attachment in attachment slot 0.
CEPL with make a <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code> with dimensions equal to that of the current <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> and with the element-type :rgba (which is a sensible default for a color
attachment)</p> <p><strong>-- (make-fbo 0 1) --</strong></p> <p>Make an fbo with two color attachments 1 in each of attachment slots 0 &amp; 1.
CEPL with make the textures with dimensions equal to that of the current
viewport and with the element-type :rgba (which is a sensible default for a
color attachment)</p> <p><strong>-- (make-fbo :d) --</strong></p> <p>Make an fbo with one depth attachment.
CEPL with make a texture with dimensions equal to that of the current viewport
and with the element-type :depth-component24 (which is a sensible default for a
depth attachment)</p> <p><strong>-- (make-fbo 0 1 :d) --</strong></p> <p>Make an fbo with two color attachments and one depth attachment.</p> <p><strong>-- (make-fbo (list 0 some-gpu-array)) --</strong></p> <p>Makes an fbo with one color attachment whos <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> is 'some-gpu-array'</p> <p><strong>--  (make-fbo (list 0 some-texture)) --</strong></p> <p>Makes an fbo with one color attachment whos gpu-array is (texref some-texture)</p> <p><strong>-- (make-fbo '(0 :dimensions (100 100) :element-type :rgba8)) --</strong></p> <p>Makes an fbo with one color attachment whos gpu-array is taken from a new
texture created by taking the arguments after 0 and applying them to <code><a href="#CEPL.TEXTURES:MAKE-TEXTURE">make-texture</a></code></p> <p><strong>-- Any combination of the above --</strong></p> <p>One last variant is allowed. You are allowed to pass a cube-map texture along
with and optional depth option. This will result in each face of the cube being
bound to the fbo's attachments.</p> <pre><code>(<a href="#CEPL.FBOS:MAKE-FBO">make-fbo</a> cube-tex)

(<a href="#CEPL.FBOS:MAKE-FBO">make-fbo</a> cube-tex '(:d :dimensions (32 32))

(<a href="#CEPL.FBOS:MAKE-FBO">make-fbo</a> cube-tex :d) ;; depth attachment dimensions will match faces
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:PER-ATTACHMENT-BLENDING-AVAILABLE-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:PER-ATTACHMENT-BLENDING-AVAILABLE-P">PER-ATTACHMENT-BLENDING-AVAILABLE-P</a> </code> <code class="qualifiers"></code> <code class="arguments"></code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will return t if you are on a version of opengl that supports
setting blending parameters on framebuffer <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>s. Otherwise it returns nil</p> <p>If the result is nil then you will only be able to change blend params on the
first attachment. You can however enable blending on any number of attachments
and they will inherit their params from attachment 0</p> <p>For more details see <code>cepl.blending</code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.FBOS:WITH-FBO-BOUND"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.FBOS:WITH-FBO-BOUND">WITH-FBO-BOUND</a> </code> <code class="qualifiers"></code> <code class="arguments">(FBO &amp;KEY (TARGET :DRAW-FRAMEBUFFER) (WITH-VIEWPORT T) (ATTACHMENT-FOR-SIZE 0)
 (WITH-BLENDING T) (DRAW-BUFFERS T))
 &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This is one macro you use when you want to capture the output from a pipeline in
an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>.</p> <p><code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code> will capture any rendering from any map-g calls inside it body.</p> <p>Also look at the docs for <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code> and <code>map-g-into*</code> for a full picture of your
options</p> <p>*<em>-- draw buffers --</em> draw-buffers is an important argument, it allows you to direct the outputs from
the fragment-shader of the pipeline into the fbo's color <code><a href="#CEPL.FBOS:ATTACHMENT">attachment</a></code>s.
This means that your pipelines can write into multiple attachments (and thus
multiple <code><a href="#CEPL.TEXTURES:TEXTURE">texture</a></code>s) at once.</p> <p>To use it either pass in:</p> <p>nil - Which means that the fbo is bound but no attachments will be draw into
      (rarely used)</p> <p>t -  Which means the all attachments will be available to be drawn into
     this will happen in order, so the first output from the fragment shader
     will draw into the first attachment, the second output to the second
     attachment, etc</p> <p><strong>-- with-viewport --</strong></p> <p>If with-viewport is t then with-fbo-bound adds a <code><a href="#CEPL.VIEWPORTS:WITH-FBO-VIEWPORT">with-fbo-viewport</a></code> that uses
this fbo to this scope. This means that the <code><a href="#CEPL.VIEWPORTS:CURRENT-VIEWPORT">current-viewport</a></code> within this scope
will be set to the equivalent of:</p> <pre><code>(<a href="#CEPL.VIEWPORTS:MAKE-VIEWPORT">make-viewport</a> dimensions-of-fbo '(0 0))
</code></pre> <p>See the docstruct <code><a href="#CEPL.VIEWPORTS:WITH-FBO-VIEWPORT">with-fbo-viewport</a></code> for details on this behavior.</p> <p>One last detail is that you may want to take the dimensions of the viewport from
an attachment other than attachment-0. To do this use the 'attachment-for-size
argument and give the index of the color-attachment to use.</p> <p><strong>-- with-blending --</strong></p> <p>If with-blending is t then <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code> adds a <code><a href="#CEPL.BLENDING:WITH-BLENDING">with-blending</a></code> that uses
this fbo to this scope.
This means that the blending parameters from your fbo will be used while
rendering. For the details and version specific behaviours check out
the docstring for cepl.blending:with-blending</p> <p><strong>-- target --</strong></p> <p>For target the choices are :framebuffer, :read_framebuffer and
:draw_framebuffer.</p> <p>You normally dont need to worry about the target as the last two are only used
when you need certain GL read and write operations to happen to different
buffers. It remains for those who know they need this but otherwise you can
let CEPL handle it.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.BLENDING" href="#CEPL.BLENDING">CEPL.BLENDING</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.BLENDING:BLENDING-PARAMS"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.BLENDING:BLENDING-PARAMS">BLENDING-PARAMS</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>Blending Parameters dictate how a color is written into an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>'s attachment if
there is already a color there.</p> <p>Blending Parameters (or <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code>) can be applied in CEPL in 3 places:</p> <ul> <li><p>On an FBO:
  This sets the rules for all attachments in the FBO</p></li> <li><p>On an FBO Attachment:
  This overrides the rules set on the FBO but only for the one attachment.
  This is only supported on some versions of OpenGL.</p></li> <li><p>On a blending-params object:
  This object can then be applied using with-blending
  (see with-blending's docstring for more info)</p></li> </ul> <p>The interaction between the options in the blending-params is fairly complex
so whilst we seek to give an introduction here, some cases will be best covered
in other documentation.</p> <p><strong>-- The Parameters --</strong></p> <p>There are 3 pairs of parameters that work together to tell GL how to compute
the final color.</p> <p>In all cases below 'source' means the color coming from the pipeline that needs
to be written into the FBO, and 'destination' means the color already in the FBO</p> <p>Conceptually what is happening is that <code><a href="#CEPL.BLENDING:SOURCE-RGB">source-rgb</a></code>, <code><a href="#CEPL.BLENDING:SOURCE-ALPHA">source-alpha</a></code>, <code><a href="#CEPL.BLENDING:DESTINATION-RGB">destination-rgb</a></code> and <code><a href="#CEPL.BLENDING:DESTINATION-ALPHA">destination-alpha</a></code> all name functions that will be called on their respective
values. This will result in new source-rgb, source-alpha, destinations-rgb and
destination-alpha values.</p> <p>Those new values are then given to the <code><a href="#CEPL.BLENDING:MODE-RGB">mode-rgb</a></code> and <code><a href="#CEPL.BLENDING:MODE-ALPHA">mode-alpha</a></code> functions which
compute the final color.</p> <p>So in pseudo-code it would look this this:</p> <pre><code>(<a href="http://l1sp.org/cl/defun">defun</a> compute-final-color (blend-params src-rgb src-alpha
                            dest-rgb dest-alpha)
  (<a href="http://l1sp.org/cl/let">let</a> ((new-src-rgb
         (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-source-rgb blend-params)
                  src-rgb
                  dest-rgb))
        (new-dest-rgb
         (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-destination-rgb blend-params)
                  src-rgb
                  dest-rgb))
        (new-src-alpha
         (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-source-alpha blend-params)
                  src-alpha
                  dest-alpha))
        (new-dest-alpha
         (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-destination-alpha blend-params)
                  src-alpha
                  dest-alpha)))
    ;; compute final colors
    (<a href="http://l1sp.org/cl/values">values</a> (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-mode-rgb blend-params)
                     new-src-rgb
                     new-dest-rgb)
            (<a href="http://l1sp.org/cl/funcall">funcall</a> (blend-params-mode-alpha blend-params)
                     new-src-alpha
                     new-dest-alpha))))
</code></pre> <p><strong>-- :source-rgb, :source-alpha, :destination-rgb &amp; :destination-alpha --</strong></p> <p>This is the list of operations and what they do to the *-rgb or *alpha values
given.</p> <pre><code>Parameter                 | RGB Factor                      | Alpha Factor
--------------------------------------------------------------------------
:zero                     | (v! 0 0 0)                      | 0
:one                      | (v! 1 1 1)                      | 1
:src-color                | (v! rs0 gs0 bs0)                | as0
:one-minus-src-color      | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! rs0 gs0 bs0)) | 1 - as0
:dst-color                | (v! rd gd bd)                   | ad
:one-minus-dst-color      | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! rd gd bd))    | 1 - ad
:src-alpha                | (v! as0 as0 as0)                | as0
:one-minus-src-alpha      | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! as0 as0 as0)) | 1 - as0
:dst-alpha                | (v! ad ad ad)                   | ad
:one-minus-dst-alpha      | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! ad ad ad))    | ad
:constant-color           | (v! rc gc bc)                   | ac
:one-minus-constant-color | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! rc gc bc))    | 1 - ac
:constant-alpha           | (v! ac ac ac)                   | ac
:one-minus-constant-alpha | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! ac ac ac))    | 1 - ac
:src-alpha-saturate       | (v! i i i)                      | 1
:src1-color               | (v! rs1 gs1 bs1)                | as1
:one-minus-src1-color     | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! rs1 gs1 bs1)) | 1 - as1
:src1-alpha               | (v! as1 as1 as1)                | as1
:one-minus-src1-alpha     | (<a href="http://l1sp.org/cl/-">-</a> (v! 1 1 1) (v! as1 as1 as1)) | 1 - as1
</code></pre> <p><strong>-- :mode-rgb &amp; :mode-alpha --</strong></p> <p>As mentioned above, to compute the final color two equations are used:
one for the RGB portion of the color, and one for the alpha of the color.
This is useful if you want treat rgb and alpha differently when producing the
end result.</p> <p>The equations available are:</p> <p>:func-add - The source and destination colors are added to each other.
            O = sS + dD. The s and d are blending parameters that are
            multiplied into each of S and D before the addition.</p> <p>:func-subtract - Subtracts the destination from the source. O = sS - dD.
                 The source and dest are again multiplied by blending
                 parameters.</p> <p>:func-reverse-subtract - Subtracts the source from the destination.
                         O = sD - dS. The source and dest are multiplied by
                         blending parameters.</p> <p>:min - The output color is the component-wise minimum value of the source
       and dest colors. So performing :min in the RGB equation means that
       Or = min(Sr, Dr), Og = min(Sg, Dg), and so forth.
       The parameters s and d are ignored for this equation.</p> <p>:max - The output color is the component-wise maximum value of the source and
       dest colors. The parameters s and d are ignored for this equation.</p> <p><strong>-- Precision --</strong></p> <p>Despite the apparent precision of the above equations, blending arithmetic is
not exactly specified, because blending operates with imprecise integer color
values.
However, a blend factor that should be equal to 1 is guaranteed not to modify
its multiplicand, and a blend factor equal to 0 reduces its multiplicand to 0.</p> <p>For example, when:</p> <ul> <li>srcRGB is GL_SRC_ALPHA</li> <li>dstRGB is GL_ONE_MINUS_SRC_ALPHA,</li> <li>As0 is equal to 1</li> </ul> <p>the equations reduce to simple replacement:</p> <blockquote> <p>todo</p> </blockquote> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:BLENDING-PARAMS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:BLENDING-PARAMS">BLENDING-PARAMS</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed an <code><a href="#CEPL.FBOS:FBO">fbo</a></code> or attachment will return the <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> for that object.</p> <p>For details on what blending-params are, see the docstring for the
blending-params struct</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:DESTINATION-ALPHA"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:DESTINATION-ALPHA">DESTINATION-ALPHA</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
function that will be applied to the alpha value that is currently in the <code><a href="#CEPL.FBOS:FBO">fbo</a></code> and is about to be combined with the value coming from the pipeline.</p> <p>The result will be one of the following:</p> <pre><code>:zero
:one
:src-color
:one-minus-src-color
:dst-color
:one-minus-dst-color
:src-alpha
:one-minus-src-alpha
:dst-alpha
:one-minus-dst-alpha
:constant-color
:one-minus-constant-color
:constant-alpha
:one-minus-constant-alpha
:src-alpha-saturate
:src1-color
:one-minus-src-color
:src1-alpha
:one-minus-src-alpha
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:DESTINATION-RGB"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:DESTINATION-RGB">DESTINATION-RGB</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
function that will be applied to the color value that is currently in the <code><a href="#CEPL.FBOS:FBO">fbo</a></code> and is about to be combined with the value coming from the pipeline.</p> <p>The result will be one of the following:</p> <pre><code>:zero
:one
:src-color
:one-minus-src-color
:dst-color
:one-minus-dst-color
:src-alpha
:one-minus-src-alpha
:dst-alpha
:one-minus-dst-alpha
:constant-color
:one-minus-constant-color
:constant-alpha
:one-minus-constant-alpha
:src-alpha-saturate
:src1-color
:one-minus-src-color
:src1-alpha
:one-minus-src-alpha
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:MODE-ALPHA"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:MODE-ALPHA">MODE-ALPHA</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
equation that will be used to compute the final alpha value from the processed <code><a href="#CEPL.BLENDING:SOURCE-ALPHA">source-alpha</a></code> and <code><a href="#CEPL.BLENDING:DESTINATION-ALPHA">destination-alpha</a></code>.</p> <p>The result will be one of the following:</p> <pre><code>:func-add
:func-subtract
:func-reverse-subtract
:min
:max
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:MODE-RGB"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:MODE-RGB">MODE-RGB</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
equation that will be used to compute the final color value from the processed <code><a href="#CEPL.BLENDING:SOURCE-RGB">source-rgb</a></code> and <code><a href="#CEPL.BLENDING:DESTINATION-RGB">destination-rgb</a></code>.</p> <p>The result will be one of the following:</p> <pre><code>:func-add
:func-subtract
:func-reverse-subtract
:min
:max
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:SOURCE-ALPHA"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:SOURCE-ALPHA">SOURCE-ALPHA</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
function that will be applied to the alpha value that is coming from the
pipeline and is to be combined with the value already in the <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> <p>The result will be one of the following:</p> <pre><code>:zero
:one
:src-color
:one-minus-src-color
:dst-color
:one-minus-dst-color
:src-alpha
:one-minus-src-alpha
:dst-alpha
:one-minus-dst-alpha
:constant-color
:one-minus-constant-color
:constant-alpha
:one-minus-constant-alpha
:src-alpha-saturate
:src1-color
:one-minus-src-color
:src1-alpha
:one-minus-src-alpha
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:SOURCE-RGB"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:SOURCE-RGB">SOURCE-RGB</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO &amp;OPTIONAL ATTACHMENT-NAME</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will return the name of the
function that will be applied to the color value that is coming from the
pipeline and is to be combined with the value already in the <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> <p>The result will be one of the following:</p> <pre><code>:zero
:one
:src-color
:one-minus-src-color
:dst-color
:one-minus-dst-color
:src-alpha
:one-minus-src-alpha
:dst-alpha
:one-minus-dst-alpha
:constant-color
:one-minus-constant-color
:constant-alpha
:one-minus-constant-alpha
:src-alpha-saturate
:src1-color
:one-minus-src-color
:src1-alpha
:one-minus-src-alpha
</code></pre> <p>To see more info on this subject please see the doc-string for the
blending-params struct.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:BLENDING-PARAMS-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:BLENDING-PARAMS-P">BLENDING-PARAMS-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t when the given value is a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object,
otherwise it returns nil</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:COPY-BLENDING-PARAMS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:COPY-BLENDING-PARAMS">COPY-BLENDING-PARAMS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object, will create a new
blending-params object with the same settings as the one passed.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:MAKE-BLENDING-PARAMS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:MAKE-BLENDING-PARAMS">MAKE-BLENDING-PARAMS</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;KEY ((:MODE-RGB MODE-RGB) :FUNC-ADD) ((:MODE-ALPHA MODE-ALPHA) :FUNC-ADD)
 ((:SOURCE-RGB SOURCE-RGB) :SRC-ALPHA)
 ((:SOURCE-ALPHA SOURCE-ALPHA) :SRC-ALPHA)
 ((:DESTINATION-RGB DESTINATION-RGB) :ONE-MINUS-SRC-ALPHA)
 ((:DESTINATION-ALPHA DESTINATION-ALPHA) :ONE-MINUS-SRC-ALPHA)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function makes a new <code><a href="#CEPL.BLENDING:BLENDING-PARAMS">blending-params</a></code> object.</p> <p>The valid values for <code><a href="#CEPL.BLENDING:SOURCE-RGB">source-rgb</a></code>, <code><a href="#CEPL.BLENDING:SOURCE-ALPHA">source-alpha</a></code>, <code><a href="#CEPL.BLENDING:DESTINATION-RGB">destination-rgb</a></code> and <code><a href="#CEPL.BLENDING:DESTINATION-ALPHA">destination-alpha</a></code> are:</p> <pre><code>:zero
:one
:src-color
:one-minus-src-color
:dst-color
:one-minus-dst-color
:src-alpha
:one-minus-src-alpha
:dst-alpha
:one-minus-dst-alpha
:constant-color
:one-minus-constant-color
:constant-alpha
:one-minus-constant-alpha
:src-alpha-saturate
:src1-color
:one-minus-src-color
:src1-alpha
:one-minus-src-alpha
</code></pre> <p>The valid values for <code><a href="#CEPL.BLENDING:MODE-RGB">mode-rgb</a></code> and <code><a href="#CEPL.BLENDING:MODE-ALPHA">mode-alpha</a></code> are:</p> <pre><code>:func-add
:func-subtract
:func-reverse-subtract
:min
:max
</code></pre> <p>For details on their behaviour on the blending-params object please see the
docstring for blending-params.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.BLENDING:WITH-BLENDING"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.BLENDING:WITH-BLENDING">WITH-BLENDING</a> </code> <code class="qualifiers"></code> <code class="arguments">BLENDING-PARAMS &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro will set the default blending parameters for the scope.</p> <p>These values will be used unless overriden by blend settings in an <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> <p>CEPL ensures the blending settings are undone at the end of the scope.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.PIPELINES" href="#CEPL.PIPELINES">CEPL.PIPELINES</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.PIPELINES:GPU-FUNCTIONS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:GPU-FUNCTIONS">GPU-FUNCTIONS</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns all the signatures of the gpu-functions named 'name'.</p> <p>The reason there may be many is that functions can be 'overloaded' so you
can have multiple gpu-functions with the same name as long as they can be
uniquely identified by the combination of their name and argument types.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DELETE-GPU-FUNCTION"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DELETE-GPU-FUNCTION">DELETE-GPU-FUNCTION</a> </code> <code class="qualifiers"></code> <code class="arguments">GFUNC-DESCRIPTION &amp;OPTIONAL ERROR-IF-MISSING</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function will delete a gpu-function this will mean it can no longer be used
in new pipelines.</p> <p>This function will only delete one function at a time, so if your gpu-function
is overloaded then you will want to specify the function signature exactly.</p> <p>See the documentation for <code><a href="#CEPL.PIPELINES:GPU-FUNCTIONS">gpu-functions</a></code> which will lists all the signatures
for the gpu-functions with a given name.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:BAKE-UNIFORMS"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:BAKE-UNIFORMS">BAKE-UNIFORMS</a> </code> <code class="qualifiers"></code> <code class="arguments">PIPELINE &amp;REST UNIFORMS &amp;KEY &amp;ALLOW-OTHER-KEYS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><strong>WARNING</strong> EXPRERIMENTAL FEATURE</p> <p>This allows you to create a new lambda-pipeline from existing pipeline whilst also
fixing the values for certain uniforms.</p> <p>These values will be baked into the gpu-code so that they will not need to be uploaded
each time the pipeline is mapped over.</p> <p>For example:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a> draw-cube ()
  :vertex (draw-cube-vert g-pnt)
  :fragment (draw-cube-frag :vec2))

(<a href="http://l1sp.org/cl/defun">defun</a> fix-cube-size (size)
  (<a href="#CEPL.PIPELINES:BAKE-UNIFORMS">bake-uniforms</a> #'draw-cube :edge-length (<a href="http://l1sp.org/cl/float">float</a> size)))
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEF-G-&gt;"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEF-G-&gt;">DEF-G-&gt;</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME CONTEXT &amp;BODY GPIPE-ARGS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><strong>WIP</strong> def-g-&gt; is the old name for <code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code>. def-g-&gt; is deprecated and will
        be removed December 2017.
        defpipeline-g does EXACTLY the same thing as def-g-&gt;</p> <p>def-g-&gt; (or defpipeline-g) is how we define named rendering pipelines in CEPL.</p> <p>Rendering pipelines are constructed by composing gpu-functions.</p> <p>Rendering in OpenGL is descibed as a pipeline where a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> of data
usually describing geometry) is mapped over whilst a number of uniforms are
available as input and the outputs are written into an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>.</p> <p>There are many stages to the pipeline and a full explanation of the GPU pipeline
is beyond the scope of this docstring. However it surfices to say that only
5 stages are fully programmable (and a few more customizable).</p> <p>def-g-&gt; lets you specify the code (shaders) to run the programmable
parts (stages) of the pipeline.</p> <p>The available stages kinds are:</p> <ul> <li>:vertex</li> <li>:tessellation-control</li> <li>:tessellation-evaluation</li> <li>:geometry</li> <li>:fragment</li> </ul> <p>To define code that runs on the gpu in CEPL we use gpu functions (gfuncs). Which
are defined with defun-g.</p> <p>Here is an example pipeline:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="#CEPL.PIPELINES:DEF-G-&gt;">def-g-&gt;</a> prog-1 ()
  (vert :vec4)
  (frag :float :float))
</code></pre> <p>Here we define a pipeline #'prog-1 which uses the gfunc vert as its vertex
shader and used the gfunc frag as the fragment shader.</p> <p>It is also possible to specify the name of the stages</p> <pre><code>(<a href="#CEPL.PIPELINES:DEF-G-&gt;">def-g-&gt;</a> prog-1 ()
  :vertex (vert :vec4)
  :fragment (frag :float :float))
</code></pre> <p>But this is not neccesary unless you need to distinguish between tessellation
or geometry stages.</p> <p><strong>-- Context --</strong></p> <p>The second argument to def-g-&gt; is the a list of additional information that is
confusingly called the 'pipeline's context'. We need to change this name.</p> <p>Valid things that can be in this list are:</p> <p><em>A primitive type:</em></p> <p>This specifies what primitives can be passed into this pipeline.
By default all pipelines expect triangles. When you map a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> over a
pipeline the primitive kind of the stream must match the pipeline.</p> <p>The valid values are:</p> <pre><code>:dynamic
:points
:lines :line-loop :line-strip
:lines-adjacency :line-strip-adjacency
:triangles :triangle-fan :triangle-strip
:triangles-adjacency :triangle-strip-adjacency
(:patch &lt;patch-size&gt;)
</code></pre> <p>:dynamic is special, it means that the pipeline will take the primitive kind
from the buffer-stream being mapped over. This won't work for with pipelines
with geometry or tessellation stages, but it otherwise quite useful.</p> <p><em>A version restriction:</em></p> <p>This tells CEPL to compile the stage for a specific
version of GLSL. You usually do not want to use this as CEPL will compile for
the version the user is using.</p> <p>The value can be one of:</p> <pre><code>:140 :150 :330 :400 :410 :420 :430 :440 :450
</code></pre> <p><strong>-- Stage Names --</strong></p> <p>Notice that we have to specify the typed signature of the stage. This is because
CEPL allows you to 'overload' gpu functions. The signature for the a
gpu-function is a list which starts with the function name and whose other
elements are the types of the non-uniforms arguments. As an example we can see
above that the signature for vert is (vert :vec4), not (vert :vec4 :float).</p> <p><strong>-- Passing values from Stage to Stage --</strong></p> <p>The return values of the gpu functions that are used as stages are passed as the
input arguments of the next. The exception to this rule is that the first return
value from the vertex stage is taken and used by GL, so only the subsequent
values are passed along.</p> <p>We can see this in the example above: #'vert returns 3 values but #'frag only
receives 2.</p> <p>The values from the fragment stage are writen into the current FBO. This may be
the default FBO, in which case you will likely see the result on the screen, or
it may be a FBO of your own.</p> <p>By default GL only writed the fragment return value to the FBO. For handling
multiple return values please see the docstring for <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code>.</p> <p><strong>-- Using our pipelines --</strong></p> <p>To call a pipeline we use the <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> macro (or one of its siblings <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code>/<code>map-g-into*</code>). The doc-strings for those macros go into more details
but the basics are that map-g maps a buffer-stream over our pipeline and the
results of the pipeline are fed into the 'current' fbo.</p> <p>We pass our stream to map-g as the first argument after the pipeline, we then
pass the uniforms in the same style as keyword arguments. For example let's see
our prog-1 pipeline again:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="#CEPL.PIPELINES:DEF-G-&gt;">def-g-&gt;</a> prog-1 ()
  (vert :vec4)
  (frag :float :float))
</code></pre> <p>We can call this as follows:</p> <pre><code>(<a href="#CEPL.PIPELINES:MAP-G">map-g</a> #'prog-1 v4-stream :i game-time)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEF-GLSL-STAGE"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEF-GLSL-STAGE">DEF-GLSL-STAGE</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME ARGS BODY-FORM OUTPUTS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>def-glsl-stage is useful when you wish to define a CEPL pipeline stage in glsl
rather than lisp. This is especially useful if you want to use some
pre-exisiting glsl without rewriting it to lisp.</p> <p>It is used like this:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEF-GLSL-STAGE">def-glsl-stage</a> frag-glsl ((&quot;color_in&quot; :vec4) &amp;context :330 :fragment)
  &quot;void main() {
       color_out = color_in;
   }&quot;
  ((&quot;color_out&quot; :vec4)))
</code></pre> <p>It differs from a regular <code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code> definition in a few ways.</p> <ul> <li><p>argument names are specified using strings.</p></li> <li><p>&amp;context is mandatory. You must specify what shader stage this can be used for
  and also what version/s this stage requires</p></li> <li><p>You are defining the entire stage, not just a function body. This means you
  can define local shader functions etc</p></li> <li><p>You have to specify the outputs in lisp as well as the inputs. This allows CEPL
  to compose this stage in pipelines with regular CEPL gpu functions.</p></li> </ul> <p>CEPL will write all the in, out and uniform definitions for your shader so do
not specify those yourself.</p> <p>This stage fully supports livecoding, so feel free to change and recomplile the
text in the stage at runtime.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEFINE-COMPILER-MACRO-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEFINE-COMPILER-MACRO-G">DEFINE-COMPILER-MACRO-G</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME LAMBDA-LIST &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This lets you define a compiler-macro that only works with gpu-functions.</p> <p>The &amp;context lambda list keyword allows you to restrict this macro to only be
valid in gpu functions with compatible contexts.</p> <p>&amp;whole and &amp;environment are not supported.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEFMACRO-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEFMACRO-G">DEFMACRO-G</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME LAMBDA-LIST &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This lets you a define a macro that only works in gpu code.</p> <p>The &amp;context lambda list keyword allows you to restrict this macro to only be
valid in gpu functions with compatible contexts.</p> <p>&amp;whole and &amp;environment are not supported.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEFPIPELINE-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEFPIPELINE-G">DEFPIPELINE-G</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME CONTEXT &amp;BODY GPIPE-ARGS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code> is how we define named rendering pipelines in CEPL.</p> <p>Rendering pipelines are constructed by composing gpu-functions.</p> <p>Rendering in OpenGL is descibed as a pipeline where a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> of data
usually describing geometry) is mapped over whilst a number of uniforms are
available as input and the outputs are written into an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>.</p> <p>There are many stages to the pipeline and a full explanation of the GPU pipeline
is beyond the scope of this docstring. However it surfices to say that only
5 stages are fully programmable (and a few more customizable).</p> <p>defpipeline-g lets you specify the code (shaders) to run the programmable
parts (stages) of the pipeline.</p> <p>The available stages kinds are:</p> <ul> <li>:vertex</li> <li>:tessellation-control</li> <li>:tessellation-evaluation</li> <li>:geometry</li> <li>:fragment</li> </ul> <p>To define code that runs on the gpu in CEPL we use gpu functions (gfuncs). Which
are defined with <code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code>.</p> <p>Here is an example pipeline:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a> prog-1 ()
  (vert :vec4)
  (frag :float :float))
</code></pre> <p>Here we define a pipeline #'prog-1 which uses the gfunc vert as its vertex
shader and used the gfunc frag as the fragment shader.</p> <p>It is also possible to specify the name of the stages</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a> prog-1 ()
  :vertex (vert :vec4)
  :fragment (frag :float :float))
</code></pre> <p>But this is not neccesary unless you need to distinguish between tessellation
or geometry stages.</p> <p><strong>-- Context --</strong></p> <p>The second argument to defpipeline-g is the a list of additional information that
is confusingly called the 'pipeline's context'. We need to change this name.</p> <p>Valid things that can be in this list are:</p> <p><em>A primitive type:</em></p> <p>This specifies what primitives can be passed into this pipeline.
By default all pipelines expect triangles. When you map a buffer-stream over a
pipeline the primitive kind of the stream must match the pipeline.</p> <p>The valid values are:</p> <pre><code>:dynamic
:points
:lines :line-loop :line-strip
:lines-adjacency :line-strip-adjacency
:triangles :triangle-fan :triangle-strip
:triangles-adjacency :triangle-strip-adjacency
(:patch &lt;patch-size&gt;)
</code></pre> <p>:dynamic is special, it means that the pipeline will take the primitive kind
from the buffer-stream being mapped over. This won't work for with pipelines
with geometry or tessellation stages, but it otherwise quite useful.</p> <p><em>A version restriction:</em></p> <p>This tells CEPL to compile the stage for a specific
version of GLSL. You usually do not want to use this as CEPL will compile for
the version the user is using.</p> <p>The value can be one of:</p> <pre><code>:140 :150 :330 :400 :410 :420 :430 :440 :450
</code></pre> <p><strong>-- Stage Names --</strong></p> <p>Notice that we have to specify the typed signature of the stage. This is because
CEPL allows you to 'overload' gpu functions. The signature for the a
gpu-function is a list which starts with the function name and whose other
elements are the types of the non-uniforms arguments. As an example we can see
above that the signature for vert is (vert :vec4), not (vert :vec4 :float).</p> <p><strong>-- Passing values from Stage to Stage --</strong></p> <p>The return values of the gpu functions that are used as stages are passed as the
input arguments of the next. The exception to this rule is that the first return
value from the vertex stage is taken and used by GL, so only the subsequent
values are passed along.</p> <p>We can see this in the example above: #'vert returns 3 values but #'frag only
receives 2.</p> <p>The values from the fragment stage are writen into the current FBO. This may be
the default FBO, in which case you will likely see the result on the screen, or
it may be a FBO of your own.</p> <p>By default GL only writed the fragment return value to the FBO. For handling
multiple return values please see the docstring for <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code>.</p> <p><strong>-- Using our pipelines --</strong></p> <p>To call a pipeline we use the <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> macro (or one of its siblings <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code>/<code>map-g-into*</code>). The doc-strings for those macros go into more details
but the basics are that map-g maps a buffer-stream over our pipeline and the
results of the pipeline are fed into the 'current' fbo.</p> <p>We pass our stream to map-g as the first argument after the pipeline, we then
pass the uniforms in the same style as keyword arguments. For example let's see
our prog-1 pipeline again:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a> prog-1 ()
  (vert :vec4)
  (frag :float :float))
</code></pre> <p>We can call this as follows:</p> <pre><code>(<a href="#CEPL.PIPELINES:MAP-G">map-g</a> #'prog-1 v4-stream :i game-time)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEFUN-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEFUN-G">DEFUN-G</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME ARGS &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code> let's you define a function which will be run on the gpu.
Commonly refered to in CEPL as a 'gpu function' or 'gfunc'</p> <p>Gpu functions try to feel similar to regular CL functions however naturally
there are some differences.</p> <p>The first and most obvious one is that whilst gpu function can be called
from other gpu functions, they cannot be called from lisp functions directly.
They first must be composed into a pipeline using <code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code>.</p> <p>When a gfunc is composed into a pipeline then that function takes on the role of
one of the 'shader stages' of the pipeline. For a proper breakdown of pipelines
see the docstring for defpipeline-g.</p> <p>Let's see a simple example of a gpu function we can then break down</p> <pre><code>;;       {0}          {3}          {1}         {2}
(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> example ((vert my-struct) &amp;uniform (<a href="http://l1sp.org/cl/loop">loop</a> :float))
  (<a href="http://l1sp.org/cl/values">values</a> (v! (<a href="http://l1sp.org/cl/+">+</a> (my-struct-pos vert) ;; {4}
                 (v! (<a href="http://l1sp.org/cl/sin">sin</a> loop) (<a href="http://l1sp.org/cl/cos">cos</a> loop) 0))
              1.0)
          (my-struct-col vert)))
</code></pre> <p>{0} So like the normal defun we specify a name first, and the arguments as a
    list straight afterwards</p> <p>{1} The &amp;uniform lambda keyword says that arguments following it are 'uniform
    arguments'. A uniform is an argument which has the same value for the entire
    stage.
    &amp;optional and &amp;key are not supported</p> <p>{2} Here is our definition for the uniform value. If used in a pipeline as a
    vertex shader #'example will be called once for every value in the <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> given. That means the 'vert' argument will have a different value
    for each of the potentially millions of invocations in that ONE pipeline
    call, however 'loop' will have the same value for the entire pipeline call.</p> <p>{2 &amp; 3} All arguments must have their types declared</p> <p>{4} Here we see we are using CL's values special form. CEPL fully supports
    multiple value return in your shaders. If our function #'example was called
    from another gpu-function then you can use multiple-value-bind to bind the
    returned values. If however our example function were used as a stage in a
    pipeline then the multiple returned values will be mapped to the multiple
    arguments of the next stage in the pipeline.</p> <p>That's the basics of gpu-functions. For more details on how they can be used
in pipelines please see the documentation for defpipeline-g.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:DEFUN-G-EQUIV"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:DEFUN-G-EQUIV">DEFUN-G-EQUIV</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME ARGS &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>Defun-g-equiv let's you define a function which will be run on the gpu.
Commonly refered to in CEPL as a 'gpu function' or 'gfunc'</p> <p>The difference between defun-g-equiv &amp; <code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code> is that defun-g will create
a 'dummy' lisp function so that 'jump to definition' and signature hits work
in your editor, defun-g-equiv does not do this.</p> <p>The advantage of defun-g-equiv is that you are then free define a lisp
equivalent of your gpu-function. This means you can use the same functions in
cpu or gpu code, which is very compelling.</p> <p><em>- the rest of the doc-string is the same as for defun-g -</em></p> <p>Gpu functions try to feel similar to regular CL functions however naturally
there are some differences.</p> <p>The first and most obvious one is that whilst gpu function can be called
from other gpu functions, they cannot be called from lisp functions directly.
They first must be composed into a pipeline using <code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code>.</p> <p>When a gfunc is composed into a pipeline then that function takes on the role of
one of the 'shader stages' of the pipeline. For a proper breakdown of pipelines
see the docstring for defpipeline-g.</p> <p>Let's see a simple example of a gpu function we can then break down</p> <pre><code>;;       {0}          {3}          {1}         {2}
(<a href="#CEPL.PIPELINES:DEFUN-G-EQUIV">defun-g-equiv</a> example ((vert my-struct) &amp;uniform (<a href="http://l1sp.org/cl/loop">loop</a> :float))
  (<a href="http://l1sp.org/cl/values">values</a> (v! (<a href="http://l1sp.org/cl/+">+</a> (my-struct-pos vert) ;; {4}
                 (v! (<a href="http://l1sp.org/cl/sin">sin</a> loop) (<a href="http://l1sp.org/cl/cos">cos</a> loop) 0))
              1.0)
          (my-struct-col vert)))
</code></pre> <p>{0} So like the normal defun we specify a name first, and the arguments as a
    list straight afterwards</p> <p>{1} The &amp;uniform lambda keyword says that arguments following it are 'uniform
    arguments'. A uniform is an argument which has the same value for the entire
    stage.
    &amp;optional and &amp;key are not supported</p> <p>{2} Here is our definition for the uniform value. If used in a pipeline as a
    vertex shader #'example will be called once for every value in the <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> given. That means the 'vert' argument will have a different value
    for each of the potentially millions of invocations in that ONE pipeline
    call, however 'loop' will have the same value for the entire pipeline call.</p> <p>{2 &amp; 3} All arguments must have their types declared</p> <p>{4} Here we see we are using CL's values special form. CEPL fully supports
    multiple value return in your shaders. If our function #'example was called
    from another gpu-function then you can use multiple-value-bind to bind the
    returned values. If however our example function were used as a stage in a
    pipeline then the multiple returned values will be mapped to the multiple
    arguments of the next stage in the pipeline.</p> <p>That's the basics of gpu-functions. For more details on how they can be used
in pipelines please see the documentation for defpipeline-g.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:G-&gt;"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:G-&gt;">G-&gt;</a> </code> <code class="qualifiers"></code> <code class="arguments">CONTEXT &amp;BODY GPIPE-ARGS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><strong>WIP</strong> g-&gt; is the old name for pipeline. g-&gt; is deprecated and will
        be removed December 2017.
        pipeline does EXACTLY the same thing as g-&gt;</p> <p><strong>WARNING</strong> EXPERIMENTAL FEATURE</p> <p>g-&gt; is how we define anonymous rendering pipelines in CEPL.</p> <p>Rendering pipelines are constructed by composing gpu-functions.</p> <p>Rendering in OpenGL is descibed as a pipeline where a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> of data
usually describing geometry) is mapped over whilst a number of uniforms are
available as input and the outputs are written into an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>.</p> <p>There are many stages to the pipeline and a full explanation of the GPU
pipeline is beyond the scope of this docstring. However it surfices to say that
only 5 stages are fully programmable (and a few more customizable).</p> <p>g-&gt; lets you specify the code (shaders) to run the programmable parts (stages)
of the pipeline.</p> <p>The available stages kinds are:</p> <ul> <li>:vertex</li> <li>:tessellation-control</li> <li>:tessellation-evaluation</li> <li>:geometry</li> <li>:fragment</li> </ul> <p>To define code that runs on the gpu in CEPL we use gpu functions (gfuncs)
Which are defined with <code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code> or lambda-g.</p> <p>Here is an example pipeline:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (<a href="#CEPL.PIPELINES:G-&gt;">g-&gt;</a> ()
    (vert :vec4)
    (frag :float :float)))
</code></pre> <p>Here we define a lambda pipeline which uses the gfunc vert as its vertex
shader and used the gfunc frag as the fragment shader.</p> <p>It is also possible to specify the name of the stages</p> <pre><code>(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (<a href="#CEPL.PIPELINES:G-&gt;">g-&gt;</a> ()
    :vertex (vert :vec4)
    :fragment (frag :float :float)))
</code></pre> <p>But this is not neccesary unless you need to distinguish between tessellation
or geometry stages.</p> <p><strong>-- Context --</strong></p> <p>The first argument to g-&gt; is the a list of additional information that is
confusingly called the 'pipeline's context'. We need to change this name.</p> <p>Valid things that can be in this list are:</p> <p><em>A primitive type:</em></p> <p>This specifies what primitives can be passed into this pipeline.
By default all pipelines expect triangles. When you map a buffer-stream over a
pipeline the primitive kind of the stream must match the pipeline.</p> <p>The valid values are:</p> <pre><code>:dynamic
:points
:lines :line-loop :line-strip
:lines-adjacency :line-strip-adjacency
:triangles :triangle-fan :triangle-strip
:triangles-adjacency :triangle-strip-adjacency
(:patch &lt;patch-size&gt;)
</code></pre> <p>:dynamic is special, it means that the pipeline will take the primitive kind
from the buffer-stream being mapped over. This won't work for with pipelines
with geometry or tessellation stages, but it otherwise quite useful.</p> <p><em>A version restriction:</em></p> <p>This tells CEPL to compile the stage for a specific
version of GLSL. You usually do not want to use this as CEPL will compile for
the version the user is using.</p> <p>The value can be one of:</p> <pre><code>:140 :150 :330 :400 :410 :420 :430 :440 :450
</code></pre> <p><strong>-- Stage Names --</strong></p> <p>Notice that we have to specify the typed signature of the stage. This is because
CEPL allows you to 'overload' gpu functions. The signature for the a
gpu-function is a list which starts with the function name and whose other
elements are the types of the non-uniforms arguments. As an example we can see
above that the signature for vert is (vert :vec4), not (vert :vec4 :float).</p> <p><strong>-- Passing values from Stage to Stage --</strong></p> <p>The return values of the gpu functions that are used as stages are passed as the
input arguments of the next. The exception to this rule is that the first return
value from the vertex stage is taken and used by GL, so only the subsequent
values are passed along.</p> <p>We can see this in the example above: #'vert returns 3 values but #'frag only
receives 2.</p> <p>The values from the fragment stage are writen into the current FBO. This may be
the default FBO, in which case you will likely see the result on the screen, or
it may be a FBO of your own.</p> <p>By default GL only writed the fragment return value to the FBO. For handling
multiple return values please see the docstring for <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code>.</p> <p><strong>-- Using our pipelines --</strong></p> <p>To call a pipeline we use the <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> macro (or one of its siblings <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code>/<code>map-g-into*</code>). The doc-strings for those macros go into more details
but the basics are that map-g maps a buffer-stream over our pipeline and the
results of the pipeline are fed into the 'current' fbo.</p> <p>We pass our stream to map-g as the first argument after the pipeline, we then
pass the uniforms in the same style as keyword arguments. For example let's see
our lambda pipeline example again:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (<a href="#CEPL.PIPELINES:G-&gt;">g-&gt;</a> ()
    (vert :vec4)
    (frag :float :float)))
</code></pre> <p>We can call this as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> some-var (make-lambda-pipeline))

(<a href="#CEPL.PIPELINES:MAP-G">map-g</a> some-var v4-stream :i game-time)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:GLAMBDA"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:GLAMBDA">GLAMBDA</a> </code> <code class="qualifiers"></code> <code class="arguments">ARGS &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><strong>WIP</strong> glambda is the old name for lambda-g. glambda is deprecated and will
        be removed December 2017.
        lambda-g does EXACTLY the same thing as glambda</p> <p>glambda let's you define an anonymous function which can run on the gpu.
Commonly refered to in CEPL as a 'gpu function' or 'gfunc'</p> <p>Gpu functions try to feel similar to regular CL functions however naturally
there are some differences.</p> <p>The first and most obvious one is that whilst gpu function can be called
from other gpu functions, they cannot be called from lisp functions directly.
They first must be composed into a pipeline using <code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code>.</p> <p>When a gfunc is composed into a pipeline then that function takes on the role
of one of the 'shader stages' of the pipeline. For a proper breakdown of
pipelines see the docstring for defpipeline-g.</p> <p>Let's see a simple example of a gpu function we can then break down</p> <pre><code>;;       {0}       {3}        {1}           {2}
(<a href="#CEPL.PIPELINES:GLAMBDA">glambda</a> ((vert my-struct) &amp;uniform (<a href="http://l1sp.org/cl/loop">loop</a> :float))
  (<a href="http://l1sp.org/cl/values">values</a> (v! (<a href="http://l1sp.org/cl/+">+</a> (my-struct-pos vert) ;; {4}
                 (v! (<a href="http://l1sp.org/cl/sin">sin</a> loop) (<a href="http://l1sp.org/cl/cos">cos</a> loop) 0))
              1.0)
          (my-struct-col vert)))
</code></pre> <p>{0} So like the normal lambda we specify the arguments (as a list) first</p> <p>{1} The &amp;uniform lambda keyword says that arguments following it are 'uniform
    arguments'. A uniform is an argument which has the same value for the entire
    stage.
    &amp;optional and &amp;key are not supported</p> <p>{2} Here is our definition for the uniform value. If used in a pipeline as a
    vertex shader #'example will be called once for every value in the <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> given. That means the 'vert' argument will have a different value
    for each of the potentially millions of invocations in that ONE pipeline
    call, however 'loop' will have the same value for the entire pipeline call.</p> <p>{2 &amp; 3} All arguments must have their types declared</p> <p>{4} Here we see we are using CL's values special form. CEPL fully supports
    multiple value return in your shaders. If our function #'example was called
    from another gpu-function then you can use multiple-value-bind to bind the
    returned values. If however our example function were used as a stage in a
    pipeline then the multiple returned values will be mapped to the multiple
    arguments of the next stage in the pipeline.</p> <p>That's the basics of gpu-functions. For more details on how they can be used
in pipelines please see the documentation for defpipeline-g.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:GPU-FUNCTION"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:GPU-FUNCTION">GPU-FUNCTION</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This is CEPL's equivalent of Common Lisp's #'function function.</p> <p>It returns the object that represents the gpu-function with the specified
signature.</p> <p>Currently there is no reason to use this function. It is only available for the
sake of completeness and future features.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:LAMBDA-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:LAMBDA-G">LAMBDA-G</a> </code> <code class="qualifiers"></code> <code class="arguments">ARGS &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>lambda-g let's you define an anonymous function which can run on the gpu.
Commonly refered to in CEPL as a 'gpu function' or 'gfunc'</p> <p>Gpu functions try to feel similar to regular CL functions however naturally
there are some differences.</p> <p>The first and most obvious one is that whilst gpu function can be called
from other gpu functions, they cannot be called from lisp functions directly.
They first must be composed into a pipeline using <code><a href="#CEPL.PIPELINES:DEFPIPELINE-G">defpipeline-g</a></code>.</p> <p>When a gfunc is composed into a pipeline then that function takes on the role
of one of the 'shader stages' of the pipeline. For a proper breakdown of
pipelines see the docstring for defpipeline-g.</p> <p>Let's see a simple example of a gpu function we can then break down</p> <pre><code>;;       {0}       {3}        {1}           {2}
(<a href="#CEPL.PIPELINES:LAMBDA-G">lambda-g</a> ((vert my-struct) &amp;uniform (<a href="http://l1sp.org/cl/loop">loop</a> :float))
  (<a href="http://l1sp.org/cl/values">values</a> (v! (<a href="http://l1sp.org/cl/+">+</a> (my-struct-pos vert) ;; {4}
                 (v! (<a href="http://l1sp.org/cl/sin">sin</a> loop) (<a href="http://l1sp.org/cl/cos">cos</a> loop) 0))
              1.0)
          (my-struct-col vert)))
</code></pre> <p>{0} So like the normal lambda we specify the arguments (as a list) first</p> <p>{1} The &amp;uniform lambda keyword says that arguments following it are 'uniform
    arguments'. A uniform is an argument which has the same value for the entire
    stage.
    &amp;optional and &amp;key are not supported</p> <p>{2} Here is our definition for the uniform value. If used in a pipeline as a
    vertex shader #'example will be called once for every value in the <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> given. That means the 'vert' argument will have a different value
    for each of the potentially millions of invocations in that ONE pipeline
    call, however 'loop' will have the same value for the entire pipeline call.</p> <p>{2 &amp; 3} All arguments must have their types declared</p> <p>{4} Here we see we are using CL's values special form. CEPL fully supports
    multiple value return in your shaders. If our function #'example was called
    from another gpu-function then you can use multiple-value-bind to bind the
    returned values. If however our example function were used as a stage in a
    pipeline then the multiple returned values will be mapped to the multiple
    arguments of the next stage in the pipeline.</p> <p>That's the basics of gpu-functions. For more details on how they can be used
in pipelines please see the documentation for defpipeline-g.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:MAP-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:MAP-G">MAP-G</a> </code> <code class="qualifiers"></code> <code class="arguments">PIPELINE-FUNC STREAM &amp;REST UNIFORMS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>The map-g macro maps a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> over our pipeline and the results of the
pipeline are fed into the 'current' <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> <p>This is how we run our pipelines and thus is how we render in CEPL.</p> <p>The arguments to map-g are going to depend on what gpu-functions were composed
in the pipeline you are calling. However the layout is always as follows.</p> <ul> <li><p>the pipeline function: The first argument is always the pipeline you wish to
  map the data over.</p></li> <li><p>The stream: The next argument will be the buffer-stream which will be used as the
  inputs to the vertex-shader of the pipeline. The type of the buffer-stream  must
  be mappable onto types of the non uniform args of the gpu-function being used
  as the vertex-shader.</p></li> <li><p>Uniform args: Next you must provide the uniform arguments. These are passed in
  the same fashion as regular &amp;key arguments.</p></li> </ul> <p>CEPL will then run the pipeline with the given args and the results will be fed
into the current FBO. If no FBO has been bound by the user then the current FBO
will be the default FBO which will most likely mean you are rendering into the
surface visable on your screen.</p> <p>If an FBO has been bound then the value/s from the fragment shader will be
written into the attachments of the FBO. To control this please see the
doc-string for <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code>. The default behaviour is that each of the
multiple returns values from the gpu-function used as the fragment shader will
be written into the respective attachments of the FBO (first value to first attachment, second value to second attachment, etc)</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:MAP-G-INTO"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:MAP-G-INTO">MAP-G-INTO</a> </code> <code class="qualifiers"></code> <code class="arguments">FBO PIPELINE-FUNC STREAM &amp;REST UNIFORMS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>The <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code> macro maps a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> over our pipeline and the results of the
pipeline are fed into the supplied <code><a href="#CEPL.FBOS:FBO">fbo</a></code>.</p> <p>This is how we run our pipelines and thus is how we render in CEPL.</p> <p>The arguments to map-g-into are going to depend on what gpu-functions were
composed in the pipeline you are calling. However the layout is always as
follows:</p> <ul> <li><p>target fbo: This is where the results of the pipeline will be written.</p></li> <li><p>the pipeline function: The first argument is always the pipeline you wish to
  map the data over.</p></li> <li><p>The stream: The next argument will be the buffer-stream which will be used as the
  inputs to the vertex-shader of the pipeline. The type of the buffer-stream  must
  be mappable onto types of the non uniform args of the gpu-function being used
  as the vertex-shader.</p></li> <li><p>Uniform args: Next you must provide the uniform arguments. These are passed in
  the same fashion as regular &amp;key arguments.</p></li> </ul> <p>CEPL will then run the pipeline with the given args and the results will be fed
into the specified FBO. The value/s from the fragment shader will be
written into the attachments of the FBO. If you need to  control this in the
fashion usualy provided by <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code> then please see the doc-string for <code>map-g-into*</code>.</p> <p>The default behaviour is that each of the multiple returns values from the
gpu-function used as the fragment shader will be written into the respective
attachments of the FBO (first value to first attachment, second value to
second attachment, etc)</p> <p>Internally map-g-into wraps call to <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> in with-fbo-bound. The with-fbo-bound
has its default configuration which means that:</p> <ul> <li>the <code><a href="#CEPL.VIEWPORTS:VIEWPORT">viewport</a></code> being will be the dimensions of the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> in the first fbo attachment</li> <li>and blending is enabled</li> </ul> <p>If you want to use map-g-into and have control over these options please use <code>map-g-into*</code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:PIPELINE-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:PIPELINE-G">PIPELINE-G</a> </code> <code class="qualifiers"></code> <code class="arguments">CONTEXT &amp;BODY GPIPE-ARGS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><strong>WARNING</strong> EXPERIMENTAL FEATURE</p> <p>pipeline is how we define anonymous rendering pipelines in CEPL.</p> <p>Rendering pipelines are constructed by composing gpu-functions.</p> <p>Rendering in OpenGL is descibed as a pipeline where a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> of data
usually describing geometry) is mapped over whilst a number of uniforms are
available as input and the outputs are written into an <code><a href="#CEPL.FBOS:FBO">FBO</a></code>.</p> <p>There are many stages to the pipeline and a full explanation of the GPU
pipeline is beyond the scope of this docstring. However it surfices to say that
only 5 stages are fully programmable (and a few more customizable).</p> <p>pipeline lets you specify the code (shaders) to run the programmable
parts (stages) of the pipeline.</p> <p>The available stages kinds are:</p> <ul> <li>:vertex</li> <li>:tessellation-control</li> <li>:tessellation-evaluation</li> <li>:geometry</li> <li>:fragment</li> </ul> <p>To define code that runs on the gpu in CEPL we use gpu functions (gfuncs)
Which are defined with <code><a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a></code> or lambda-g.</p> <p>Here is an example pipeline:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (pipeline ()
    (vert :vec4)
    (frag :float :float)))
</code></pre> <p>Here we define a lambda pipeline which uses the gfunc vert as its vertex
shader and used the gfunc frag as the fragment shader.</p> <p>It is also possible to specify the name of the stages</p> <pre><code>(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (pipeline ()
    :vertex (vert :vec4)
    :fragment (frag :float :float)))
</code></pre> <p>But this is not neccesary unless you need to distinguish between tessellation
or geometry stages.</p> <p><strong>-- Context --</strong></p> <p>The first argument to pipeline-g is the a list of additional information that
is confusingly called the 'pipeline's context'. We need to change this name.</p> <p>Valid things that can be in this list are:</p> <p><em>A primitive type:</em></p> <p>This specifies what primitives can be passed into this pipeline.
By default all pipelines expect triangles. When you map a buffer-stream over a
pipeline the primitive kind of the stream must match the pipeline.</p> <p>The valid values are:</p> <pre><code>:dynamic
:points
:lines :line-loop :line-strip
:lines-adjacency :line-strip-adjacency
:triangles :triangle-fan :triangle-strip
:triangles-adjacency :triangle-strip-adjacency
(:patch &lt;patch-size&gt;)
</code></pre> <p>:dynamic is special, it means that the pipeline will take the primitive kind
from the buffer-stream being mapped over. This won't work for with pipelines
with geometry or tessellation stages, but it otherwise quite useful.</p> <p><em>A version restriction:</em></p> <p>This tells CEPL to compile the stage for a specific
version of GLSL. You usually do not want to use this as CEPL will compile for
the version the user is using.</p> <p>The value can be one of:</p> <pre><code>:140 :150 :330 :400 :410 :420 :430 :440 :450
</code></pre> <p><strong>-- Stage Names --</strong></p> <p>Notice that we have to specify the typed signature of the stage. This is because
CEPL allows you to 'overload' gpu functions. The signature for the a
gpu-function is a list which starts with the function name and whose other
elements are the types of the non-uniforms arguments. As an example we can see
above that the signature for vert is (vert :vec4), not (vert :vec4 :float).</p> <p><strong>-- Passing values from Stage to Stage --</strong></p> <p>The return values of the gpu functions that are used as stages are passed as the
input arguments of the next. The exception to this rule is that the first return
value from the vertex stage is taken and used by GL, so only the subsequent
values are passed along.</p> <p>We can see this in the example above: #'vert returns 3 values but #'frag only
receives 2.</p> <p>The values from the fragment stage are writen into the current FBO. This may be
the default FBO, in which case you will likely see the result on the screen, or
it may be a FBO of your own.</p> <p>By default GL only writed the fragment return value to the FBO. For handling
multiple return values please see the docstring for <code><a href="#CEPL.FBOS:WITH-FBO-BOUND">with-fbo-bound</a></code>.</p> <p><strong>-- Using our pipelines --</strong></p> <p>To call a pipeline we use the map-g macro (or one of its siblings <code><a href="#CEPL.PIPELINES:MAP-G-INTO">map-g-into</a></code>/<code>map-g-into*</code>). The doc-strings for those macros go into more details
but the basics are that map-g maps a buffer-stream over our pipeline and the
results of the pipeline are fed into the 'current' fbo.</p> <p>We pass our stream to map-g as the first argument after the pipeline, we then
pass the uniforms in the same style as keyword arguments. For example let's see
our lambda pipeline example again:</p> <pre><code>(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> vert ((position :vec4) &amp;uniform (i :float))
  (<a href="http://l1sp.org/cl/values">values</a> position (<a href="http://l1sp.org/cl/sin">sin</a> i) (<a href="http://l1sp.org/cl/cos">cos</a> i)))

(<a href="#CEPL.PIPELINES:DEFUN-G">defun-g</a> frag ((s :float) (c :float))
  (v! s c 0.4 1.0))

(<a href="http://l1sp.org/cl/defun">defun</a> make-lambda-pipeline ()
  (pipeline ()
    (vert :vec4)
    (frag :float :float)))
</code></pre> <p>We can call this as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/setf">setf</a> some-var (make-lambda-pipeline))

(<a href="#CEPL.PIPELINES:MAP-G">map-g</a> some-var v4-stream :i game-time)
</code></pre> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIPELINES:WITH-INSTANCES"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIPELINES:WITH-INSTANCES">WITH-INSTANCES</a> </code> <code class="qualifiers"></code> <code class="arguments">COUNT &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>The with-instances macro is used to enable instancing. You specify number number
of instances with the count argument.</p> <p>An example of its usage is as follows:</p> <pre><code>(<a href="#CEPL.PIPELINES:WITH-INSTANCES">with-instances</a> 1000
  (<a href="#CEPL.PIPELINES:MAP-G">map-g</a> #'draw-grass grass-data :tex *grass-texture*))
</code></pre> <p>This behaves kind of like you had written the following..</p> <pre><code>(<a href="http://l1sp.org/cl/dotimes">dotimes</a> (x 1000)
  (<a href="#CEPL.PIPELINES:MAP-G">map-g</a> #'draw-grass grass-data :tex *grass-texture*))
</code></pre> <p>..except MUCH more efficiently as you did not have to submit 1000 draw calls.</p> <p>Another difference is that, in the pipeline, the variable gl-instance-id will
contain the index of which of the 1000 instances is currently being drawn.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.IMAGE-FORMATS" href="#CEPL.IMAGE-FORMATS">CEPL.IMAGE-FORMATS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*BPTC-COMPRESSED-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*BPTC-COMPRESSED-FORMATS*">*BPTC-COMPRESSED-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's bptc compressed formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*COLOR-RENDERABLE-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*COLOR-RENDERABLE-FORMATS*">*COLOR-RENDERABLE-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's color renderable formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*DEPTH-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*DEPTH-FORMATS*">*DEPTH-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's depth formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*DEPTH-STENCIL-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*DEPTH-STENCIL-FORMATS*">*DEPTH-STENCIL-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's depth stencil formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*FLOATING-POINT-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*FLOATING-POINT-FORMATS*">*FLOATING-POINT-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's floating point formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*IMAGE-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*IMAGE-FORMATS*">*IMAGE-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's image formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*RED/GREEN-COMPRESSED-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*RED/GREEN-COMPRESSED-FORMATS*">*RED/GREEN-COMPRESSED-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's red/green compressed formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*REGULAR-COLOR-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*REGULAR-COLOR-FORMATS*">*REGULAR-COLOR-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's regular color formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*S3TC/DXT-COMPESSED-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*S3TC/DXT-COMPESSED-FORMATS*">*S3TC/DXT-COMPESSED-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's s3tc/dxt compessed formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*SIGNED-INTEGRAL-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*SIGNED-INTEGRAL-FORMATS*">*SIGNED-INTEGRAL-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's signed integral formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*SIGNED-NORMALIZED-INTEGER-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*SIGNED-NORMALIZED-INTEGER-FORMATS*">*SIGNED-NORMALIZED-INTEGER-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's signed normalized integer formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*SPECIAL-COLOR-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*SPECIAL-COLOR-FORMATS*">*SPECIAL-COLOR-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's special color formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*SRGB-COLOR-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*SRGB-COLOR-FORMATS*">*SRGB-COLOR-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's srgb color formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*STENCIL-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*STENCIL-FORMATS*">*STENCIL-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's stencil formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*UNSIGNED-INTEGRAL-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*UNSIGNED-INTEGRAL-FORMATS*">*UNSIGNED-INTEGRAL-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's unsigned integral formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*UNSIGNED-NORMALIZED-INTEGER-FORMATS*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*UNSIGNED-NORMALIZED-INTEGER-FORMATS*">*UNSIGNED-NORMALIZED-INTEGER-FORMATS*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's unsigned normalized integer formats</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:*VALID-IMAGE-FORMATS-FOR-BUFFER-BACKED-TEXTURE*"> </a> <article> <header class="special">  <h4 class="name"> <code> <a href="#CEPL.IMAGE-FORMATS:*VALID-IMAGE-FORMATS-FOR-BUFFER-BACKED-TEXTURE*">*VALID-IMAGE-FORMATS-FOR-BUFFER-BACKED-TEXTURE*</a> </code> </h4> <i class="type">special</i>  </header> <div class="docstring"><p>A list of all of OpenGL's valid image formats for buffer backed texture</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:COLOR-RENDERABLE-FORMATP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:COLOR-RENDERABLE-FORMATP">COLOR-RENDERABLE-FORMATP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>color-renderable-formats</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:DEPTH-FORMATP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:DEPTH-FORMATP">DEPTH-FORMATP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>depth-formats</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:DEPTH-STENCIL-FORMATP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:DEPTH-STENCIL-FORMATP">DEPTH-STENCIL-FORMATP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>depth-stencil-formats</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:IMAGE-FORMATP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:IMAGE-FORMATP">IMAGE-FORMATP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>image-formats</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:STENCIL-FORMATP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:STENCIL-FORMATP">STENCIL-FORMATP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>stencil-formats</em></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.IMAGE-FORMATS:VALID-IMAGE-FORMAT-FOR-BUFFER-BACKED-TEXTUREP"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.IMAGE-FORMATS:VALID-IMAGE-FORMAT-FOR-BUFFER-BACKED-TEXTUREP">VALID-IMAGE-FORMAT-FOR-BUFFER-BACKED-TEXTUREP</a> </code> <code class="qualifiers"></code> <code class="arguments">FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the value provided is a keyword that can be found in <em>valid-image-formats-for-buffer-backed-texture</em></p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.PIXEL-FORMATS" href="#CEPL.PIXEL-FORMATS">CEPL.PIXEL-FORMATS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">PIXEL-FORMAT</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>s exist to aid the handling and conversion of types in CEPL.</p> <p>OpenGL does not make it easy to understand the types involved with textures.</p> <p>First there is the name of the type you would use in lisp (or C)</p> <p>Then there is the image-format (sometimes called internal-format) which
specifies the format on the GPU</p> <p>Then there are the types and formats that must be specified when uploading or
downloading data to/from a texture (or rather a texture-backed gpu-array).</p> <p>CEPL's pixel-fromat pulls together enough metadata that conversions to and from
these various representations is easy.</p> <p>Technically you shouldnt need to use this directly as it will be handled by CEPL
however if you ever have to deal with the formats directly, this type can be a
boon.</p> <p>It doesnt cover every combination yet, but will in time. Anything missing is
considered a bug, so please report it on Github so it can be added to the todo
list.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-COMP-LENGTH"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-COMP-LENGTH">PIXEL-FORMAT-COMP-LENGTH</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function when passed a <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code> will return the number of components
it has. The values will be from 1 upto 4</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-COMPONENTS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-COMPONENTS">PIXEL-FORMAT-COMPONENTS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the components of the given <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code> as a keyword</p> <p>possible values are:
:r
:rg
:rgb
:rgba
:stencil-only
:depth</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-NORMALIZE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-NORMALIZE">PIXEL-FORMAT-NORMALIZE</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns whether values of the components belonging to the <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code> are normalized.</p> <p>If t then sampling the values on the gpu will gives values in the
range 0s0 → 1s0</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-REVERSED"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-REVERSED">PIXEL-FORMAT-REVERSED</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Some <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>s are 'reversed' meaning the component order in the data is
reversed.</p> <p>This function will return t if the pixel format provided is a reversed-type</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-SIZES"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-SIZES">PIXEL-FORMAT-SIZES</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Some <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>s and image-formats are 'special' and have specifically sized
components.</p> <p>This function will return a list of sizes in bits of the components.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-TYPE"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-TYPE">PIXEL-FORMAT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the lisp type of a single 'element' of the given <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>.</p> <p>For example:
- the element type of a :vec3 is a :float.
- the element type of a :vec2 is a :float.
- the element type of a :int8 is a :int8</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.PIXEL-FORMATS:PIXEL-FORMAT-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT-P">PIXEL-FORMAT-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the the given value is a <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>. Otherwise it
returns nil</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.UBOS" href="#CEPL.UBOS">CEPL.UBOS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.UBOS:UBO">UBO</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>A <code><a href="#CEPL.UBOS:UBO">UBO</a></code> is a structure that abstracts an OpenGL Uniform Buffer Object</p> <p>A Ubo is chunk of data stored in a <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>, which can be used as a uniform
in shader pipelines.</p> <p>The advantage of using a UBO over just passing the data as regular unforms is
that UBOs can be used to share uniforms between different programs, as well as
quickly change between sets of uniforms for the same pipeline.</p> <p>Let's expand on that a little:</p> <p>Switching between uniform buffer bindings is typically faster than switching
dozens of uniforms in a pipeline.</p> <p>Also, uniform buffer objects can typically store more data than non-buffered
uniforms. So they can be used to store and access larger blocks of data than
unbuffered uniform values.</p> <p>Lastly, they can be used to share information between different programs.
So modifying a single buffer can effectively allow uniforms in multiple programs
to be updated.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO-DATA"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:UBO-DATA">UBO-DATA</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>Returns the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> that contains the data presented by this <code><a href="#CEPL.UBOS:UBO">UBO</a></code></p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO-ID"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:UBO-ID">UBO-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function return the id of the GL UBO abstracted by this CEPL <code><a href="#CEPL.UBOS:UBO">UBO</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO-INDEX"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:UBO-INDEX">UBO-INDEX</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns the index into the ubo-data where the element defined by
this <code><a href="#CEPL.UBOS:UBO">ubo</a></code> is located</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO-OWNS-GPU-ARRAY"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:UBO-OWNS-GPU-ARRAY">UBO-OWNS-GPU-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns t if the <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> was created by <code><a href="#CEPL.UBOS:MAKE-UBO">make-ubo</a></code> or nil if it is
using data from a gpu-array passed to make-ubo</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:MAKE-UBO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:MAKE-UBO">MAKE-UBO</a> </code> <code class="qualifiers"></code> <code class="arguments">DATA &amp;OPTIONAL ELEMENT-TYPE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function will make and return a new <code><a href="#CEPL.UBOS:UBO">ubo</a></code></p> <p>You need only provide an element type and the lisp data to populate that type.</p> <p>For example, given the following type:</p> <p>(defstruct-g test
     (scale :float :accessor scale)
     (age :int))</p> <p>You create a ubo using this type as follows:</p> <pre><code>(<a href="#CEPL.UBOS:MAKE-UBO">make-ubo</a> '(1.2 10) 'test)
</code></pre> <p>If you wish to make a ubo from an element of a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> or <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> please
see the #'make-ubo-from-array function</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:MAKE-UBO-FROM-ARRAY"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:MAKE-UBO-FROM-ARRAY">MAKE-UBO-FROM-ARRAY</a> </code> <code class="qualifiers"></code> <code class="arguments">DATA &amp;OPTIONAL (INDEX 0) ELEMENT-TYPE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a lisp-array, <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> or <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and an index.
It returns a new <code><a href="#CEPL.UBOS:UBO">ubo</a></code> with the specified element as the data of the ubo.</p> <p>If made from a c-array or lisp-array, a fresh gpu memory is allocated to hold
the data</p> <p>If made from a gpu-array the ubo simply holds a reference to the gpu-array
and the index. No new memory is allocated. This means that if that
gpu-array is destroyed then this ubo is in an invalid state.</p> <p>This also means it is possible to do invalid things when rendering. For example
say you used the ubo as an input whilst streaming vertex data from the same
array. Consult GL documentation for details on such exceptional cases.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.UBOS:UBO-DATA-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.UBOS:UBO-DATA-TYPE">UBO-DATA-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">UBO</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns the type of the data that is contained in the <code><a href="#CEPL.UBOS:UBO">UBO</a></code></p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.GPU-BUFFERS" href="#CEPL.GPU-BUFFERS">CEPL.GPU-BUFFERS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:GPU-BUFFER"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">GPU-BUFFER</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p><code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> is a struct that abstracts a OpenGL 'Buffer Object'</p> <p>Along with the the ID of the GL Object itself it stores the unformatted data
as an array of <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s.</p> <p>Every <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> in the buffer will have an element-type of :uint8, even if this
buffer was created for a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> with a different element-type.</p> <p>For example:</p> <pre><code>(<a href="#CEPL.GPU-ARRAYS:MAKE-GPU-ARRAY">make-gpu-array</a> '(.1 .2 .3 .4))
</code></pre> <p>will make a <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> of 4 floats. However the buffer backing this <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> will contain a single array with element-type :uint8 and a length of 16.</p> <p>It is not expected that users will be using <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>s directly. Instead they
are ususal interacted with via CEPL's <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> and ubo features.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:GPU-BUFFER-ARRAYS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:GPU-BUFFER-ARRAYS">GPU-BUFFER-ARRAYS</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function returns an array of the raw :uint8 <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s that make up the
data in this <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:GPU-BUFFER-ID"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:GPU-BUFFER-ID">GPU-BUFFER-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">INSTANCE</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> will return the OpenGL buffer object
from the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> <p>It is not recommended to modify this directly as the changes from doing so won't
be reflected in the layout of the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>, which may potentially put the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> (and and <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code> or <code><a href="#CEPL.UBOS:UBO">ubo</a></code> using it) into an invalid state.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:BUFFER-DATA"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:BUFFER-DATA">BUFFER-DATA</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER C-ARRAY &amp;KEY (TARGET :ARRAY-BUFFER) (USAGE :STATIC-DRAW) (OFFSET 0)
 BYTE-SIZE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function populates the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> with the contents of the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> <p>You also pass in the buffer type and the draw type this buffer is to be used
for.</p> <p>The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:BUFFER-DATA-RAW"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:BUFFER-DATA-RAW">BUFFER-DATA-RAW</a> </code> <code class="qualifiers"></code> <code class="arguments">DATA-POINTER BYTE-SIZE BUFFER &amp;OPTIONAL (TARGET :ARRAY-BUFFER)
 (USAGE :STATIC-DRAW) (BYTE-OFFSET 0)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function populates an opengl buffer with the 'data-byte-size' bytes of data
from the given point, optionally at the offset provided.</p> <p>You also pass in the buffer type and the draw type this buffer is to be
used for.</p> <p>The function returns a buffer object with its format slot populated with the
details of the data stored within the buffer</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:BUFFER-RESERVE-BLOCK"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:BUFFER-RESERVE-BLOCK">BUFFER-RESERVE-BLOCK</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER TYPE DIMENSIONS TARGET USAGE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function creates an empty block of data in the opengl buffer equal in size
to:</p> <pre><code>(<a href="http://l1sp.org/cl/*">*</a> length size-in-bytes-of-type).
</code></pre> <p>It will remove ALL data currently in the buffer</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:FREE-BUFFER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:FREE-BUFFER">FREE-BUFFER</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when passed a <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> will free the memory on the gpu and
'blank' the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> <p>Blanking in this case means that the slots of the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> will all be set to
default values.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:FREE-BUFFERS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:FREE-BUFFERS">FREE-BUFFERS</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFERS</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when passed a list of  gpus-buffer will free the gpu memory for
all the gpus-buffers and 'blank' them.</p> <p>Blanking in this case means that the slots of each <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> will all be set to
default values.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:GPU-BUFFER-P"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:GPU-BUFFER-P">GPU-BUFFER-P</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns t if the given value is a <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>. Otherwise it
returns nil.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:MAKE-GPU-BUFFER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:MAKE-GPU-BUFFER">MAKE-GPU-BUFFER</a> </code> <code class="qualifiers"></code> <code class="arguments">&amp;KEY INITIAL-CONTENTS (BUFFER-TARGET :ARRAY-BUFFER) (USAGE :STATIC-DRAW)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function creates and returns a new <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> <p>If you wish to populate the buffer during construction you can pass a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> as
the :initial-contents.</p> <p>The :usage argument is a hint to OpenGL on how you intend to use the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.</p> <p>The :target argument can take any of the following binding targets:</p> <pre><code>Buffer Binding Target      Purpose
-------------------------------------------------------------
:array-buffer              Vertex attributes
:atomic-counter-buffer     Atomic counter storage
:copy-read-buffer          Buffer copy source
:copy-write-buffer         Buffer copy destination
:dispatch-indirect-buffer  Indirect compute dispatch commands
:draw-indirect-buffer      Indirect command arguments
:element-array-buffer      Vertex array indices
:pixel-pack-buffer         Pixel read target
:pixel-unpack-buffer       Texture data source
:query-buffer              Query result buffer
:shader-storage-buffer     Read-write storage for shaders
:texture-buffer            Texture data buffer
:transform-feedback-buffer Transform feedback buffer
:uniform-buffer            Uniform block storage
</code></pre> <p>Do note that the default of :array-buffer is perfectly fine for creating the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> and uploading the data. It does not limit how the buffer can be used
in future parts of your program.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:MAKE-GPU-BUFFER-FROM-ID"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:MAKE-GPU-BUFFER-FROM-ID">MAKE-GPU-BUFFER-FROM-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">GL-OBJECT &amp;KEY INITIAL-CONTENTS (BUFFER-TARGET :ARRAY-BUFFER)
 (USAGE :STATIC-DRAW)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes an existing GL Buffer Object and wraps it in a new <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> <p>If you wish to populate the buffer during construction you can pass a <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code> as
the :initial-contents.</p> <p>The :usage argument is a hint to OpenGL on how you intend to use the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.
It is optional whether your gpu manufacturer's implementation of GL takes any
notice of this option. When they do take notice of it, it will to optimize
access to the underlying data.</p> <p>The :target argument can take any of the following binding targets:</p> <pre><code>Buffer Binding Target      Purpose
-------------------------------------------------------------
:array-buffer              Vertex attributes
:atomic-counter-buffer     Atomic counter storage
:copy-read-buffer          Buffer copy source
:copy-write-buffer         Buffer copy destination
:dispatch-indirect-buffer  Indirect compute dispatch commands
:draw-indirect-buffer      Indirect command arguments
:element-array-buffer      Vertex array indices
:pixel-pack-buffer         Pixel read target
:pixel-unpack-buffer       Texture data source
:query-buffer              Query result buffer
:shader-storage-buffer     Read-write storage for shaders
:texture-buffer            Texture data buffer
:transform-feedback-buffer Transform feedback buffer
:uniform-buffer            Uniform block storage
</code></pre> <p>Do note that the default of :array-buffer is perfectly fine for creating the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> and uploading the data. It does not limit how the buffer can be used
in future parts of your program.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:MULTI-BUFFER-DATA"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:MULTI-BUFFER-DATA">MULTI-BUFFER-DATA</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER C-ARRAYS TARGET USAGE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a list of <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>s and uploads all of the data to the <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:REALLOCATE-BUFFER"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:REALLOCATE-BUFFER">REALLOCATE-BUFFER</a> </code> <code class="qualifiers"></code> <code class="arguments">BUFFER</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function takes a buffer and recreates the data-store for it. All data currently in the buffer will be lost.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.GPU-BUFFERS:WITH-BUFFER"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.GPU-BUFFERS:WITH-BUFFER">WITH-BUFFER</a> </code> <code class="qualifiers"></code> <code class="arguments">(VAR-NAME BUFFER &amp;OPTIONAL (BUFFER-TARGET :ARRAY-BUFFER)) &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>This macro binds the given <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> to the target on the GL Context for the
duration of the body.</p> <p>The <code><a href="#CEPL.GPU-BUFFERS:GPU-BUFFER">gpu-buffer</a></code> is then unbound at the end.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.VAOS" href="#CEPL.VAOS">CEPL.VAOS</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.VAOS:FREE-VAO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VAOS:FREE-VAO">FREE-VAO</a> </code> <code class="qualifiers"></code> <code class="arguments">VAO</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Takes a GL VAO and deletes it</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VAOS:FREE-VAOS"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VAOS:FREE-VAOS">FREE-VAOS</a> </code> <code class="qualifiers"></code> <code class="arguments">VAOS</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>Takes a list of GL VAOs and deletes them.</p> <p>This function exists as a minor optimization.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VAOS:MAKE-VAO"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VAOS:MAKE-VAO">MAKE-VAO</a> </code> <code class="qualifiers"></code> <code class="arguments">GPU-ARRAYS &amp;OPTIONAL INDEX-ARRAY</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function returns a new GL VAO when given</p> <ul> <li>a list of gpu-arrays</li> <li>optionally 1 gpu-array to be used as an index</li> </ul> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VAOS:MAKE-VAO-FROM-ID"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VAOS:MAKE-VAO-FROM-ID">MAKE-VAO-FROM-ID</a> </code> <code class="qualifiers"></code> <code class="arguments">GL-OBJECT GPU-ARRAYS &amp;OPTIONAL INDEX-ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function takes an existing OpenGL VAO and set it up to strema vertices from
the given arrays.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.VAOS:WITH-VAO-BOUND"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.VAOS:WITH-VAO-BOUND">WITH-VAO-BOUND</a> </code> <code class="qualifiers"></code> <code class="arguments">VAO &amp;BODY BODY</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p>Binds the <code>vao</code> to the gl context and guarentees it will be unbound after the
body scope.</p> <p>Usually you will not need to interact with the vao directly as you can simply
use a <code><a href="#CEPL.STREAMS:BUFFER-STREAM">buffer-stream</a></code> and let <code><a href="#CEPL.PIPELINES:MAP-G">map-g</a></code> handle when it should be bound and
unbound.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.TYPES" href="#CEPL.TYPES">CEPL.TYPES</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.TYPES:IMAGE-FORMAT-&gt;LISP-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:IMAGE-FORMAT-&gt;LISP-TYPE">IMAGE-FORMAT-&gt;LISP-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">IMAGE-FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when given a image-format name, will attempt to find and
return the name of a lisp type that is equivalent.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:IMAGE-FORMAT-&gt;PIXEL-FORMAT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:IMAGE-FORMAT-&gt;PIXEL-FORMAT">IMAGE-FORMAT-&gt;PIXEL-FORMAT</a> </code> <code class="qualifiers"></code> <code class="arguments">IMAGE-FORMAT &amp;KEY (ERROR-IF-MISSING T)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when given an image-format name, will attempt to find and
return equivalent equivalent <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:LISP-TYPE-&gt;IMAGE-FORMAT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:LISP-TYPE-&gt;IMAGE-FORMAT">LISP-TYPE-&gt;IMAGE-FORMAT</a> </code> <code class="qualifiers"></code> <code class="arguments">LISP-TYPE</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when given a lisp type name, will attempt to find and
return the name of a GL image-format that is equivalent.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:PIXEL-FORMAT-&gt;IMAGE-FORMAT"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:PIXEL-FORMAT-&gt;IMAGE-FORMAT">PIXEL-FORMAT-&gt;IMAGE-FORMAT</a> </code> <code class="qualifiers"></code> <code class="arguments">PIXEL-FORMAT &amp;KEY (ERROR-IF-MISSING T)</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when given a <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code> object, will attempt to find and
return the name of a GL image-format that is equivalent.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:PIXEL-FORMAT-&gt;LISP-TYPE"> </a> <article> <header class="function">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:PIXEL-FORMAT-&gt;LISP-TYPE">PIXEL-FORMAT-&gt;LISP-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">PIXEL-FORMAT</code> <code>)</code> </h4> <i class="type">function</i>  </header> <div class="docstring"><p>This function, when given a <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code> object, will attempt to find and
return the name of a lisp type that is equivalent.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:ELEMENT-BYTE-SIZE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:ELEMENT-BYTE-SIZE">ELEMENT-BYTE-SIZE</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>Returns the size in bytes taken up by a single element of the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:ELEMENT-TYPE"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:ELEMENT-TYPE">ELEMENT-TYPE</a> </code> <code class="qualifiers"></code> <code class="arguments">ARRAY</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>Returns the type of the elements in the <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:GET-TYPED-FROM-FOREIGN"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:GET-TYPED-FROM-FOREIGN">GET-TYPED-FROM-FOREIGN</a> </code> <code class="qualifiers"></code> <code class="arguments">TYPE-NAME</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function, when given a foreign type name returns a function that when given
a pointer reads the named type foreign from the pointer.</p> <p>For example</p> <pre><code>(<a href="#CEPL.TYPES:GET-TYPED-FROM-FOREIGN">get-typed-from-foreign</a> :vec3)
</code></pre> <p>returns a function that when given a pointer to a :vec3 will return a lisp vec3.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:GET-TYPED-TO-FOREIGN"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:GET-TYPED-TO-FOREIGN">GET-TYPED-TO-FOREIGN</a> </code> <code class="qualifiers"></code> <code class="arguments">TYPE-NAME</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function, when given a foreign type name returns a function that when given
a pointer and a lisp value, converts and writes the value to the foreign
location specified by the pointer pointer.</p> <p>For example:</p> <pre><code>(<a href="#CEPL.TYPES:GET-TYPED-TO-FOREIGN">get-typed-to-foreign</a> :vec3)
</code></pre> <p>returns a function that when given a pointer and a lisp vec3 will write the
 value into foreign memory.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:LISP-TYPE-&gt;PIXEL-FORMAT"> </a> <article> <header class="generic">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:LISP-TYPE-&gt;PIXEL-FORMAT">LISP-TYPE-&gt;PIXEL-FORMAT</a> </code> <code class="qualifiers"></code> <code class="arguments">TYPE</code> <code>)</code> </h4> <i class="type">generic</i>  </header> <div class="docstring"><p>This function, when given a lisp type name, will attempt to find and
return an equivalent <code><a href="#CEPL.PIXEL-FORMATS:PIXEL-FORMAT">pixel-format</a></code>.</p> <p>If no such type is found then nil is returned</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES:DEFSTRUCT-G"> </a> <article> <header class="macro">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES:DEFSTRUCT-G">DEFSTRUCT-G</a> </code> <code class="qualifiers"></code> <code class="arguments">NAME-AND-OPTIONS &amp;BODY SLOT-DESCRIPTIONS</code> <code>)</code> </h4> <i class="type">macro</i>  </header> <div class="docstring"><p><code><a href="#CEPL.TYPES:DEFSTRUCT-G">defstruct-g</a></code> defines a struct that can be used both gpu-side (in gpu functions, <code><a href="#CEPL.GPU-ARRAYS:GPU-ARRAY">gpu-array</a></code>s, <code>ubos</code>, etc) and also cpu-side (in <code><a href="#CEPL.C-ARRAYS:C-ARRAY">c-array</a></code>s, other gstructs, etc)</p> <p>You create these using defstruct-g so lets look at an example right now:</p> <pre><code>(<a href="#CEPL.TYPES:DEFSTRUCT-G">defstruct-g</a> our-data
  (<a href="http://l1sp.org/cl/position">position</a> :vec3)
  (val :int :accessor val))
</code></pre> <p>This should seem familiar if you have used common lisp's structs.</p> <p>You provide a name (with options if you need them) and the definitions for the
slots. The format for a slot is:</p> <pre><code>(slot-name slot-type)

-or-

(slot-name slot-type :accessor accessor-name)
</code></pre> <p>-- make-* --</p> <p>Once defined you would create the above struct as follows:</p> <pre><code>(<a href="http://l1sp.org/cl/defvar">defvar</a> x (make-our-data :position (v! 1 2 3) :val 5))
</code></pre> <p>This will return a fully populated struct in foreign memory. if values are not
provided then the slots will be left uninitialized and the contents of the slot
are unknown (and likely unsafe)
It is rather rare to make a one-off struct like this as it is much more common
to use the type in a data-structure like a c-arrays or gpu-array.</p> <p>-- Accessors --</p> <p>In the 'our-data' example above, the slot named 'position' doesnt have an
accesor but the 'val' slot does.</p> <p>Both slots will get a lisp-struct-style accessor functions however because of
the :accessor in val's slot definition a generic function named by the symbol
after :accessor will also be created.</p> <p>For the example this means the functions #'our-data-position, #'our-data-val and
the generic function #'val are available.</p> <p>Whilst :accessor results in a generic function on the cpu side (with the
associated overheads) on the gpu side the function to be used is resolved
statically and so there is not performance cost.</p> <p>-- Options --</p> <p>With the exception of :constructor the options for defstruct-g are rarely used
but are documented here for the sake of completeness.</p> <p>:constructor
  Setting this to nil means that you will get <em>no</em> make- function
  Setting this to any other symbol will name the constructor using that symbol
  The default will is that the constructor will be called make-<struct-name/></p> <p>:readers
  Setting this to nil means that you will get <em>no</em> functions to get the
  slots' data</p> <p>:writers
  Setting this to nil means that you will get <em>no</em> setf functions to set the
  slots' data</p> <p>:accesors
  Setting this to nil means that you will get <em>neither</em> of the above.</p> <p>:pull-push
  Setting this to nil means that you will get <em>no</em> <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> or <code><a href="#CEPL.MEMORY:PULL-G">pull-g</a></code> methods
  defined for your type</p> <p>:attribs
  Setting this to nil means that defstruct-g will not be able to make
  buffer-streams from arrays of this type.</p> <p>:populate
  Setting this to nil means that you will not get a internal populate function
  for this type. <DEPRECATED/></p> <p>Some of the above options are redundent in combination with others.
For example the <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> method uses #'populate behind the scenes so with
populate disabled you can have <code><a href="#CEPL.MEMORY:PUSH-G">push-g</a></code> for this type.</p> <p>CEPL currently does a poor job at communicating these conflicts to the user.</p> </div> </article> </li></ul> </li><li class="package" style="list-style-type: none"> <h3> <a name="CEPL.TYPES.PREDEFINED" href="#CEPL.TYPES.PREDEFINED">CEPL.TYPES.PREDEFINED</a> <span class="nicknames"/> </h3> <ul><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PC"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PC">G-PC</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pc is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  color: of type vec4 with an accessor method: col</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PN"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PN">G-PN</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pn is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PNC"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PNC">G-PNC</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pnc is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  color: of type vec4 with an accessor method: col</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PNT"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PNT">G-PNT</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pnt is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PNTC"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PNTC">G-PNTC</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pntc is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  normal: of type vec3 with an accessor method: norm
  texture: of type vec2 with an accessor method: tex
  color: of type vec4 with an accessor method: col</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:G-PT"> </a> <article> <header class="class">  <h4 class="name"> <code> <a href="#CEPL.TYPES.PREDEFINED:G-PT">G-PT</a> </code> </h4> <i class="type">class</i>  </header> <div class="docstring"><p>g-pt is a CEPL gpu struct with the following slots:</p> <p>position: of type vec3 with an accessor method: pos
  texture: of type vec2 with an accessor method: tex</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:BI-TANGENT"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:BI-TANGENT">BI-TANGENT</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec3 which is the bi-tangent of the instance.</p> <p>You can alternatively use the generic function #'bi-tangent to get this value.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:COL"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:COL">COL</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec4 which is the color of the instance.</p> <p>You can alternatively use the generic function #'col to get this value.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:NORM"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:NORM">NORM</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec3 which is the normal of the instance.</p> <p>You can alternatively use the generic function #'norm to get this value.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:POS"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:POS">POS</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec3 which is the position of the instance.</p> <p>You can alternatively use the generic function #'pos to get this value.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:TANGENT"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:TANGENT">TANGENT</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec3 which is the tangent of the instance.</p> <p>You can alternatively use the generic function #'tangent to get this value.</p> </div> </article> </li><li style="list-style-type: none"> <a name="CEPL.TYPES.PREDEFINED:TEX"> </a> <article> <header class="accessor">  <h4 class="name"> <code>(</code> <code> <a href="#CEPL.TYPES.PREDEFINED:TEX">TEX</a> </code> <code class="qualifiers"></code> <code class="arguments">OBJECT</code> <code>)</code> </h4> <i class="type">accessor</i>  </header> <div class="docstring"><p>This function, returns a :vec2 which is the texture of the instance.</p> <p>You can alternatively use the generic function #'tex to get this value.</p> </div> </article> </li></ul> </li></ul> </article>  </div> </body> </html> 